<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;mojito&#x2F;lib&#x2F;app&#x2F;addons&#x2F;rs&#x2F;yui.js - Mojito API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;developer.yahoo.com&#x2F;cocktails&#x2F;mojito&#x2F;api&#x2F;assets&#x2F;img&#x2F;mojito-logo-white-bkg.png" title="Mojito API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.7.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ActionContext.html">ActionContext</a></li>
            
                <li><a href="..&#x2F;classes/Analytics.common.html">Analytics.common</a></li>
            
                <li><a href="..&#x2F;classes/Assets.common.html">Assets.common</a></li>
            
                <li><a href="..&#x2F;classes/Composite.common.html">Composite.common</a></li>
            
                <li><a href="..&#x2F;classes/Config.common.html">Config.common</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.client.html">Cookie.client</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.server.html">Cookie.server</a></li>
            
                <li><a href="..&#x2F;classes/Data.common.data.html">Data.common.data</a></li>
            
                <li><a href="..&#x2F;classes/Data.common.pageData.html">Data.common.pageData</a></li>
            
                <li><a href="..&#x2F;classes/Deploy.server.html">Deploy.server</a></li>
            
                <li><a href="..&#x2F;classes/Helpers.common.html">Helpers.common</a></li>
            
                <li><a href="..&#x2F;classes/Http.server.html">Http.server</a></li>
            
                <li><a href="..&#x2F;classes/Intl.common.html">Intl.common</a></li>
            
                <li><a href="..&#x2F;classes/Meta.common.html">Meta.common</a></li>
            
                <li><a href="..&#x2F;classes/Model.Vanilla.html">Model.Vanilla</a></li>
            
                <li><a href="..&#x2F;classes/Models.common.html">Models.common</a></li>
            
                <li><a href="..&#x2F;classes/MojitoDispatcher.html">MojitoDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/MojitoPerf.html">MojitoPerf</a></li>
            
                <li><a href="..&#x2F;classes/MojitoRouter.html">MojitoRouter</a></li>
            
                <li><a href="..&#x2F;classes/MojitProxy.html">MojitProxy</a></li>
            
                <li><a href="..&#x2F;classes/OutputBuffer.html">OutputBuffer</a></li>
            
                <li><a href="..&#x2F;classes/OutputHandler.html">OutputHandler</a></li>
            
                <li><a href="..&#x2F;classes/Params.common.html">Params.common</a></li>
            
                <li><a href="..&#x2F;classes/Partial.common.html">Partial.common</a></li>
            
                <li><a href="..&#x2F;classes/ResourceStore.server.html">ResourceStore.server</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonConfig.html">RSAddonConfig</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonDispatchHelper.html">RSAddonDispatchHelper</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonMime.html">RSAddonMime</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonSelector.html">RSAddonSelector</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonUrl.html">RSAddonUrl</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonYUI.html">RSAddonYUI</a></li>
            
                <li><a href="..&#x2F;classes/Url.common.html">Url.common</a></li>
            
                <li><a href="..&#x2F;classes/Y.mojito.Client.html">Y.mojito.Client</a></li>
            
                <li><a href="..&#x2F;classes/Y.mojito.lib.REST.html">Y.mojito.lib.REST</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ActionContext.html">ActionContext</a></li>
            
                <li><a href="..&#x2F;modules/ActionContextAddon.html">ActionContextAddon</a></li>
            
                <li><a href="..&#x2F;modules/app.html">app</a></li>
            
                <li><a href="..&#x2F;modules/CommonLibs.html">CommonLibs</a></li>
            
                <li><a href="..&#x2F;modules/Data.common.html">Data.common</a></li>
            
                <li><a href="..&#x2F;modules/model-vanilla.html">model-vanilla</a></li>
            
                <li><a href="..&#x2F;modules/mojito-perf.html">mojito-perf</a></li>
            
                <li><a href="..&#x2F;modules/MojitoClient.html">MojitoClient</a></li>
            
                <li><a href="..&#x2F;modules/MojitoHooks.html">MojitoHooks</a></li>
            
                <li><a href="..&#x2F;modules/OutputBuffer.html">OutputBuffer</a></li>
            
                <li><a href="..&#x2F;modules/ResourceStore.html">ResourceStore</a></li>
            
                <li><a href="..&#x2F;modules/ResourceStoreAddon.html">ResourceStoreAddon</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;mojito&#x2F;lib&#x2F;app&#x2F;addons&#x2F;rs&#x2F;yui.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2012, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 *&#x2F;

&#x2F;*jslint anon:true, nomen:true, stupid:true, continue:true, node:true*&#x2F;
&#x2F;*global YUI*&#x2F;


&#x2F;**
 * @module ResourceStoreAddon
 *&#x2F;


&#x2F;**
 * @class RSAddonYUI
 * @extension ResourceStore.server
 *&#x2F;
YUI.add(&#x27;addon-rs-yui&#x27;, function(Y, NAME) {

    &#x27;use strict&#x27;;

    var libfs   = require(&#x27;fs&#x27;),
        libpath = require(&#x27;path&#x27;),
        libvm   = require(&#x27;vm&#x27;),
        libmime = require(&#x27;mime&#x27;),
        liburl  = require(&#x27;url&#x27;),
        libutil = require(&#x27;..&#x2F;..&#x2F;..&#x2F;util.js&#x27;),

        WARN_SERVER_MODULES = &#x2F;\b(dom-[\w\-]+|node-[\w\-]+|io-upload-iframe)&#x2F;ig,
        MODULE_SUBDIRS = {
            autoload: true,
            tests: true,
            yui_modules: true
        },

        &#x2F;&#x2F; creating a vm context to execute all files
        &#x2F;&#x2F; we want to reuse it because it is 200x faster
        &#x2F;&#x2F; than creating a new one per file
        contextForRunInContext = libvm.createContext({
            require: require,
            module: require(&#x27;module&#x27;),
            console: {
                log: function() {}
            },
            window: {},
            document: {},
            YUI: null
        }),

        resourceSortByDepthTest = function (a, b) {
            return a.source.pkg.depth - b.source.pkg.depth;
        },

        yuiSandboxFactory = require(libpath.join(__dirname, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;yui-sandbox.js&#x27;)),
        syntheticStat = null,

        MODULE_META_ENTRIES          = [&#x27;path&#x27;, &#x27;requires&#x27;, &#x27;use&#x27;, &#x27;optional&#x27;, &#x27;skinnable&#x27;, &#x27;after&#x27;, &#x27;condition&#x27;, &#x27;lang&#x27;],
        &#x2F;&#x2F; TODO: revisit this list with @davglass
        MODULE_META_PRIVATE_ENTRIES  = [&#x27;after&#x27;, &#x27;expanded&#x27;, &#x27;supersedes&#x27;, &#x27;ext&#x27;, &#x27;_parsed&#x27;, &#x27;_inspected&#x27;, &#x27;skinCache&#x27;, &#x27;langCache&#x27;],

        REGEX_LANG_TOKEN = &#x2F;\&quot;\{langToken\}\&quot;&#x2F;g,
        REGEX_LANG_PATH  = &#x2F;\{langPath\}&#x2F;g,
        REGEX_LOCALE     = &#x2F;\_([a-z]{2}(-[A-Z]{2})?)$&#x2F;,

        MODULE_PER_LANG  = [&#x27;loader-app-base&#x27;, &#x27;loader-app-resolved&#x27;, &#x27;loader-yui3-base&#x27;, &#x27;loader-yui3-resolved&#x27;],
        MODULE_TEMPLATES = {
            &#x2F;*
             * This is a replacement of the original loader to include loader-app
             * module, which represents the meta of the app.
             *&#x2F;
            &#x27;loader-app&#x27;:
                &#x27;YUI.add(&quot;loader&quot;,function(Y){&#x27; +
                &#x27;},&quot;&quot;,{requires:[&quot;loader-base&quot;,&quot;loader-yui3&quot;,&quot;loader-app&quot;]});&#x27;,

            &#x2F;*
             * Use this module when you want to rely on the loader to do recursive
             * computations to resolve combo urls for app yui modules in the client
             * runtime.
             * Note: This is the default config used by YUI.
             *&#x2F;
            &#x27;loader-app-base&#x27;:
                &#x27;YUI.add(&quot;loader-app&quot;,function(Y){&#x27; +
                    &#x27;Y.applyConfig({groups:{app:Y.merge(&#x27; +
                        &#x27;((Y.config.groups&amp;&amp;Y.config.groups.app)||{}),&#x27; +
                        &#x27;{modules:{app-base}}&#x27; +
                    &#x27;)}});&#x27; +
                &#x27;},&quot;&quot;,{requires:[&quot;loader-base&quot;]});&#x27;,

            &#x2F;*
             * Use this module when you want to precompute the loader metadata to
             * avoid doing recursive computations to resolve combo urls for app yui modules
             * in the client runtime.
             * Note: Keep in mind that this meta is considerable bigger than &quot;loader-app-base&quot;.
             *&#x2F;
            &#x27;loader-app-resolved&#x27;:
                &#x27;YUI.add(&quot;loader-app&quot;,function(Y){&#x27; +
                    &#x27;Y.applyConfig({groups:{app:Y.merge(&#x27; +
                        &#x27;((Y.config.groups&amp;&amp;Y.config.groups.app)||{}),&#x27; +
                        &#x27;{modules:{app-resolved}}&#x27; +
                    &#x27;)}});&#x27; +
                &#x27;},&quot;&quot;,{requires:[&quot;loader-base&quot;]});&#x27;,

            &#x2F;*
             * Use this module when you want to rely on the loader to do recursive
             * computations to resolve combo urls for yui core modules in the client
             * runtime.
             * Note: This is a more restrictive configuration than the default
             * meta bundle with yui, but it is considerable smaller, which helps
             * with performance.
             *&#x2F;
            &#x27;loader-yui3-base&#x27;:
                &#x27;YUI.add(&quot;loader-yui3&quot;,function(Y){&#x27; +
                    &#x2F;&#x2F; TODO: we should use YUI.applyConfig() instead of the internal
                    &#x2F;&#x2F;       YUI.Env API, but that&#x27;s pending due a bug in YUI:
                    &#x2F;&#x2F;       http:&#x2F;&#x2F;yuilibrary.com&#x2F;projects&#x2F;yui3&#x2F;ticket&#x2F;2532854
                    &#x27;YUI.Env[Y.version].modules=YUI.Env[Y.version].modules||&#x27; +
                    &#x27;{yui-base};&#x27; +
                &#x27;},&quot;&quot;,{requires:[&quot;loader-base&quot;]});&#x27;,

            &#x2F;*
             * Use this module when you want to precompute the loader metadata to
             * avoid doing recursive computations to resolve combo urls for yui core
             * modules in the client runtime.
             * Note: Keep in mind that this meta is considerable bigger than &quot;loader-yui3-base&quot;.
             *&#x2F;
            &#x27;loader-yui3-resolved&#x27;:
                &#x27;YUI.add(&quot;loader-yui3&quot;,function(Y){&#x27; +
                    &#x2F;&#x2F; TODO: we should use YUI.applyConfig() instead of the internal
                    &#x2F;&#x2F;       YUI.Env API, but that&#x27;s pending due a bug in YUI:
                    &#x2F;&#x2F;       http:&#x2F;&#x2F;yuilibrary.com&#x2F;projects&#x2F;yui3&#x2F;ticket&#x2F;2532854
                    &#x27;YUI.Env[Y.version].modules=YUI.Env[Y.version].modules||&#x27; +
                    &#x27;{yui-resolved};&#x27; +
                &#x27;},&quot;&quot;,{requires:[&quot;loader-base&quot;]});&#x27;
        };

    function RSAddonYUI() {
        RSAddonYUI.superclass.constructor.apply(this, arguments);
    }
    RSAddonYUI.NS = &#x27;yui&#x27;;

    Y.extend(RSAddonYUI, Y.Plugin.Base, {

        &#x2F;**
         * This methods is part of Y.Plugin.Base.  See documentation for that for details.
         * @method initializer
         * @param {object} config Configuration object as per Y.Plugin.Base
         * @return {nothing}
         *&#x2F;
        initializer: function(config) {
            this.host = config.host;
            this.appRoot = config.appRoot;
            this.mojitoRoot = config.mojitoRoot;

            &#x2F;&#x2F; for all synthetic files, since we don&#x27;t have an actual file, we need to
            &#x2F;&#x2F; create a stat object, in this case we use the mojito folder stat as
            &#x2F;&#x2F; a replacement. We make it syncronous since it is meant to be executed
            &#x2F;&#x2F; once during the preload process.
            syntheticStat = libfs.statSync(libpath.join(__dirname, &#x27;..&#x2F;..&#x2F;..&#x2F;..&#x27;));

            this.afterHostMethod(&#x27;findResourceVersionByConvention&#x27;, this.findResourceVersionByConvention, this);
            this.beforeHostMethod(&#x27;parseResourceVersion&#x27;, this.parseResourceVersion, this);
            this.beforeHostMethod(&#x27;addResourceVersion&#x27;, this.addResourceVersion, this);
            this.beforeHostMethod(&#x27;makeResourceVersions&#x27;, this.makeResourceVersions, this);
            this.afterHostMethod(&#x27;resolveResourceVersions&#x27;, this.resolveResourceVersions, this);
            this.beforeHostMethod(&#x27;getResourceContent&#x27;, this.getResourceContent, this);
            this.onHostEvent(&#x27;loadConfigs&#x27;, this.loadConfigs, this);

            this.loadConfigs();

            this.langs = {};            &#x2F;&#x2F; keys are list of languages in the app, values are simply &quot;true&quot;
            this.resContents = {};      &#x2F;&#x2F; res.id: contents
            this.appModulesDetails = {};    &#x2F;&#x2F; res.yui.name: static handler details
            this.yuiModulesDetails = {};    &#x2F;&#x2F; res.yui.name: static handler details
        },

        loadConfigs: function () {
            this.staticAppConfig = this.host.getStaticAppConfig() || {};
            this.staticHandling = this.staticAppConfig.staticHandling || {};
            this.staticPrefix = libutil.webpath(&#x27;&#x2F;&#x27;, (this.staticHandling.prefix || &#x27;static&#x27;), &quot;&#x2F;&quot;);
            this.yuiConfig = (this.staticAppConfig.yui &amp;&amp; this.staticAppConfig.yui.config) || {};
        },

        &#x2F;**
         * Returns a datastructure which tells a YUI instance where to find
         * the YUI modules that are shared among all mojits.
         * @method getConfigShared
         * @param {string} env runtime environment (either &#x60;client&#x60;, or &#x60;server&#x60;)
         * @return {object} datastructure for configuring YUI
         *&#x2F;
        getConfigShared: function(env) {
            var r,
                res,
                ress,
                modules = {};
            ress = this.get(&#x27;host&#x27;).getResourceVersions({ mojit: &#x27;shared&#x27; });
            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];
                if (!res.yui || !res.yui.name) {
                    continue;
                }
                if (res.affinity.affinity !== env &amp;&amp; res.affinity.affinity !== &#x27;common&#x27;) {
                    continue;
                }
                modules[res.yui.name] = this._makeYUIModuleConfig(env, res);
            }
            return { modules: modules };
        },


        &#x2F;**
         * Returns a datastructure which tells a YUI instance where to find
         * the YUI modules in the app.
         * @method getModulesConfig
         * @param {string} env runtime environment (either &#x60;client&#x60;, or &#x60;server&#x60;)
         * @param {boolean} justApp Indicates whether to include the YUI
         *      modules just found in the application (true), or also include
         *      those found in mojito (false).
         * @return {object} datastructure for configuring YUI
         *&#x2F;
        getModulesConfig: function(env, justApp) {
            var store = this.get(&#x27;host&#x27;),
                m,
                mojit,
                mojits,
                r,
                res,
                ress,
                modules = {};

            mojits = store.listAllMojits();
            mojits.push(&#x27;shared&#x27;);
            for (m = 0; m &lt; mojits.length; m += 1) {
                mojit = mojits[m];
                ress = store.getResourceVersions({ mojit: mojit });
                ress.sort(resourceSortByDepthTest);
                for (r = 0; r &lt; ress.length; r += 1) {
                    res = ress[r];
                    if (!res.yui || !res.yui.name) {
                        continue;
                    }
                    if (res.affinity.affinity !== env &amp;&amp; res.affinity.affinity !== &#x27;common&#x27;) {
                        continue;
                    }
                    if (justApp &amp;&amp; (&#x27;mojito&#x27; === res.source.pkg.name)) {
                        continue;
                    }
                    &#x2F;&#x2F; don&#x27;t overwrite resource if it&#x27;s there already
                    modules[res.yui.name] = modules[res.yui.name] || this._makeYUIModuleConfig(env, res);
                }
            }
            return { modules: modules };
        },


        &#x2F;**
         * Hook to allow other RS addons to control the yui
         * configuration. By default, the &#x60;yui.config&#x60; will
         * allow customization of the combo handler when needed
         * from &#x60;application.json&#x60;.
         * @method getYUIConfig
         * @param {object} ctx the context
         * @return {object} yui configuration
         *&#x2F;
        getYUIConfig: function(ctx) {
            var version = Y.version,
                yuiPrefix = libutil.webpath(this.staticPrefix, &#x27;yui&#x2F;&#x27;),
                appConfig = this.get(&#x27;host&#x27;).getAppConfig(ctx),
                yuiConfig;

            if (this.staticHandling.serveYUIFromAppOrigin) {

                &#x2F;&#x2F; by default, we want to serve YUI from CDN
                yuiConfig = {

                    maxURLLength: 1024,
                    base: yuiPrefix,
                    comboBase: &quot;&#x2F;combo~&quot;,
                    comboSep: &quot;~&quot;,
                    root: yuiPrefix

                };

            } else {

                yuiConfig = {

                    &#x2F;&#x2F; the base path for non-combo paths
                    base: &#x27;http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;&#x27; + version + &#x27;&#x2F;&#x27;,
                    &#x2F;&#x2F; the path to the combo service
                    comboBase: &#x27;http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?&#x27;,
                    comboSep: &#x27;&amp;&#x27;,
                    &#x2F;&#x2F; a fragment to prepend to the path attribute when
                    &#x2F;&#x2F; when building combo urls
                    root: version + &#x27;&#x2F;&#x27;

                };

            }

            yuiConfig = Y.merge(yuiConfig, {
                fetchCSS: true,
                combine: true
            }, (appConfig.yui &amp;&amp; appConfig.yui.config) || {});

            &#x2F;&#x2F; to boot the app in the client with the proper lang
            yuiConfig.lang = ctx.lang;

            yuiConfig.groups = yuiConfig.groups || {};
            yuiConfig.groups.app = this.getAppGroupConfig(ctx, yuiConfig);
            yuiConfig.seed = this.getAppSeedFiles(ctx, yuiConfig);

            return yuiConfig;
        },


        &#x2F;**
         * Hook to allow other RS addons to control the combo
         * handler configuration for group &quot;app&quot;. By default,
         * the &#x60;yui.config.groups.app&#x60; will allow customization
         * of the combo handler when needed from &#x60;application.json&#x60;
         * @method getAppGroupConfig
         * @param {object} ctx the context
         * @return {object} yui configuration for group &quot;app&quot;
         *&#x2F;
        getAppGroupConfig: function(ctx) {
            var appConfig = this.get(&#x27;host&#x27;).getAppConfig(ctx),
                yuiConfig = (appConfig.yui &amp;&amp; appConfig.yui.config) || {};

            return Y.merge({
                combine: (yuiConfig.combine === false) ? false : true,
                maxURLLength: 1024,
                base: this.staticPrefix,
                comboBase: &quot;&#x2F;combo~&quot;,
                comboSep: &quot;~&quot;,
                root: this.staticPrefix
            }, ((yuiConfig.groups &amp;&amp; yuiConfig.groups.app) || {}));
        },


        &#x2F;**
         * Produce the YUI seed files. This can be controlled through
         * application.json-&gt;yui-&gt;config-&gt;seed in a form of
         * a array with the list of full paths for all seed files.
         * @method getAppSeedFiles
         * @param {object} ctx the context
         * @param {object} yuiConfig the config that is sent to client
         * @return {array} list of seed files
         *&#x2F;
        getAppSeedFiles: function(ctx, yuiConfig) {

            yuiConfig = yuiConfig || {}; &#x2F;&#x2F; to support legacy

            var files = [],
                seed = Y.Array(yuiConfig.seed || []),
                appGroupConfig = (yuiConfig.groups &amp;&amp; yuiConfig.groups.app) || {},
                hash = {},
                appModules = [],
                yuiModules = [],
                filter = yuiConfig.filter || &#x27;min&#x27;,
                file,
                lang,
                i;

            &#x2F;&#x2F; picking up the closest language based on yui config
            &#x2F;&#x2F; of from the yui bundles
            lang = Y.mojito.util.findClosestLang(ctx.lang, this.langs);

            function newEntry(f) {
                &#x2F;&#x2F; flushing any pending combo for yui core modules
                if (yuiModules.length &gt; 0) {
                    files.push(yuiConfig.comboBase + yuiModules.join(yuiConfig.comboSep));
                    yuiModules = [];
                }
                &#x2F;&#x2F; flushing any pending combo for app modules
                if (appModules.length &gt; 0) {
                    files.push(appGroupConfig.comboBase + appModules.join(appGroupConfig.comboSep));
                    appModules = [];
                }
                if (f) {
                    files.push(f);
                }
            }

            &#x2F;&#x2F; adjusting filter to be url friendly
            filter = filter === &#x27;raw&#x27; ? &#x27;&#x27; : &#x27;-&#x27; + filter;

            &#x2F;&#x2F; adjusting lang just to be url friendly
            lang = lang ? &#x27;_&#x27; + lang : &#x27;&#x27;;

            &#x2F;&#x2F; The seed files collection is lang aware, hence we should adjust
            &#x2F;&#x2F; is on runtime.
            for (i = 0; i &lt; seed.length; i += 1) {

                &#x2F;&#x2F; adjusting the seed based on {langToken} to facilitate
                &#x2F;&#x2F; the customization of the seed file url per lang.
                seed[i] = seed[i].replace(REGEX_LANG_PATH, lang);

                if (hash.hasOwnProperty(seed[i])) {

                    Y.log(&#x27;Skiping duplicated entry in yui.config.seed: &#x27; + seed[i], &#x27;warn&#x27;, NAME);

                } else if (liburl.parse(seed[i]).protocol) {

                    newEntry(seed[i]);

                } else if (this.appModulesDetails.hasOwnProperty(seed[i])) {

                    &#x2F;&#x2F; app module
                    file = this.appModulesDetails[seed[i]].url.split(&#x27;&#x2F;&#x27;).pop();
                    &#x2F;&#x2F; default app module
                    if (appGroupConfig.combine === false) {
                        &#x2F;&#x2F; if the combo is disabled, then we need to insert one by one
                        &#x2F;&#x2F; this is useful for offline and hybrid apps where the combo
                        &#x2F;&#x2F; does not work.
                        newEntry(appGroupConfig.base + file);
                    } else {
                        &#x2F;&#x2F; the item is a module and should be combined
                        appModules.push(appGroupConfig.root + file);
                    }

                } else {

                    &#x2F;&#x2F; assume yui core module
                    file = seed[i] + &#x27;&#x2F;&#x27; + seed[i] + filter + &#x27;.js&#x27;;
                    &#x2F;&#x2F; the module is a yui core module, treat is accordingly
                    if (yuiConfig.combine === false) {
                        &#x2F;&#x2F; if the combo is disabled, then we need to insert one by one
                        &#x2F;&#x2F; this is useful for offline and hybrid apps where the combo
                        &#x2F;&#x2F; does not work.
                        newEntry(yuiConfig.base + file);
                    } else {
                        &#x2F;&#x2F; the item is a module and should be combined
                        yuiModules.push(yuiConfig.root + file);
                    }

                }
                &#x2F;&#x2F; hash table to avoid duplicated entries in the seed
                hash[seed[i]] = true;
            }

            newEntry(); &#x2F;&#x2F; just to flush any remaining entry

            return files;
        },


        &#x2F;**
         * Aggregate all yui core files
         * using the path of as the hash.
         *
         * @private
         * @method getYUIURLDetails
         * @return {object} yui core resources by url
         *&#x2F;
        getYUIURLDetails: function () {
            var name,
                urls = {};

            for (name in this.yuiModulesDetails) {
                if (this.yuiModulesDetails.hasOwnProperty(name)) {
                    urls[this.yuiModulesDetails[name].url] = this.yuiModulesDetails[name];
                }
            }
            return urls;
        },


        &#x2F;**
         * Using AOP, this is called after the ResourceStore&#x27;s version.
         * @method findResourceVersionByConvention
         * @param {object} source metadata about where the resource is located
         * @param {string} mojitType name of mojit to which the resource likely belongs
         * @return {object||null} for yui modules or lang bundles, returns metadata signifying that
         *&#x2F;
        findResourceVersionByConvention: function(source, mojitType) {
            var fs = source.fs;

            if (!fs.isFile) {
                return;
            }
            if (&#x27;.js&#x27; !== fs.ext) {
                return;
            }

            if (fs.subDirArray.length &gt;= 1 &amp;&amp; MODULE_SUBDIRS[fs.subDirArray[0]]) {
                return new Y.Do.AlterReturn(null, {
                    type: &#x27;yui-module&#x27;,
                    skipSubdirParts: 1
                });
            }

            if (fs.subDirArray.length &gt;= 1 &amp;&amp; &#x27;lang&#x27; === fs.subDirArray[0]) {
                return new Y.Do.AlterReturn(null, {
                    type: &#x27;yui-lang&#x27;,
                    skipSubdirParts: 1
                });
            }
        },


        &#x2F;**
         * Using AOP, this is called before the ResourceStore&#x27;s version.
         * @method parseResourceVersion
         * @param {object} source metadata about where the resource is located
         * @param {string} type type of the resource
         * @param {string} subtype subtype of the resource
         * @param {string} mojitType name of mojit to which the resource likely belongs
         * @return {object||null} for yui modules or lang bundles, returns the resource metadata
         *&#x2F;
        parseResourceVersion: function(source, type, subtype, mojitType) {
            var store = this.get(&#x27;host&#x27;),
                fs = source.fs,
                baseParts,
                res,
                sandbox;

            if (&#x27;yui-lang&#x27; === type) {
                res = {
                    source: source,
                    mojit: mojitType,
                    type: &#x27;yui-lang&#x27;,
                    affinity: &#x27;common&#x27;,
                    selector: &#x27;*&#x27;
                };
                if (!res.yui) {
                    res.yui = {};
                }
                sandbox = {
                    Intl: {
                        add: function(langFor, lang) {
                            res.yui.langFor = langFor;
                            res.yui.lang = lang;
                        }
                    }
                };
                this._captureYUIModuleDetails(res, sandbox);
                res.name = res.yui.name;
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                this.langs[res.yui.lang] = true;
                if (res.yui.name === &#x27;lang&#x2F;&#x27; + res.yui.langFor) {
                    res.yui.isRootLang = true;
                }
                return new Y.Do.Halt(null, res);
            }

            if (&#x27;yui-module&#x27; === type) {
                baseParts = fs.basename.split(&#x27;.&#x27;);
                res = {
                    source: source,
                    mojit: mojitType,
                    type: &#x27;yui-module&#x27;,
                    affinity: &#x27;server&#x27;,
                    selector: &#x27;*&#x27;
                };
                if (baseParts.length &gt;= 3) {
                    res.selector = baseParts.pop();
                }
                if (baseParts.length &gt;= 2) {
                    res.affinity = baseParts.pop();
                }
                if (baseParts.length !== 1) {
                    Y.log(&#x27;invalid yui-module filename. skipping &#x27; + fs.fullPath, &#x27;warn&#x27;, NAME);
                    return;
                }
                this._captureYUIModuleDetails(res);
                res.name = res.yui.name;
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                return new Y.Do.Halt(null, res);
            }
        },


        &#x2F;**
         * Using AOP, this is called before the ResourceStore&#x27;s version.
         * If the resource is a YUI module, augments the metadata with details
         * about the YUI module.
         * @method addResourceVersion
         * @param {object} res resource version metadata
         * @return {nothing}
         *&#x2F;
        addResourceVersion: function(res) {
            if (&#x27;.js&#x27; !== res.source.fs.ext) {
                return;
            }
            if (res.yui &amp;&amp; res.yui.name) {
                &#x2F;&#x2F; work done already
                return;
            }
            &#x2F;&#x2F; ASSUMPTION:  no app-level resources are YUI modules
            if (!res.mojit) {
                return;
            }
            if (&#x27;asset&#x27; === res.type) {
                return;
            }
            this._captureYUIModuleDetails(res);
        },


        &#x2F;**
         * Using AOP, this is called before the ResourceStore&#x27;s version.
         * We register some fake resource versions that represent the YUI
         * configurations.
         * @method addResourceVersion
         * @param {object} res resource version metadata
         * @return {nothing}
         *&#x2F;
        makeResourceVersions: function() {
            &#x2F;&#x2F;console.log(&#x27;------------------------------------------- YUI makeResourceVersions&#x27;);
            var store = this.get(&#x27;host&#x27;),
                l,
                i,
                lang,
                name,
                langExt,
                langs = Object.keys(this.langs),
                res;

            &#x2F;&#x2F; we always want to make the no-lang version
            if (!this.langs[&#x27;&#x27;]) {
                langs.push(&#x27;&#x27;);
            }

            res = {
                source: {},
                mojit: &#x27;shared&#x27;,
                type: &#x27;yui-module&#x27;,
                subtype: &#x27;synthetic&#x27;,
                name: &#x27;loader-app&#x27;,
                affinity: &#x27;client&#x27;,
                selector: &#x27;*&#x27;,
                yui: {
                    name: &#x27;loader-app&#x27;
                }
            };
            res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
            res.source.pkg = store.getAppPkgMeta();
            res.source.fs = store.makeResourceFSMeta(this.appRoot, &#x27;app&#x27;, &#x27;.&#x27;, &#x27;loader-app.js&#x27;, true);
            store.addResourceVersion(res);

            for (l = 0; l &lt; langs.length; l += 1) {
                lang = langs[l];
                langExt = lang ? &#x27;_&#x27; + lang : &#x27;&#x27;;

                for (i = 0; i &lt; MODULE_PER_LANG.length; i += 1) {

                    name = MODULE_PER_LANG[i];

                    res = {
                        source: {},
                        mojit: &#x27;shared&#x27;,
                        type: &#x27;yui-module&#x27;,
                        subtype: &#x27;synthetic&#x27;,
                        name: [name, lang].join(&#x27;-&#x27;),
                        affinity: &#x27;client&#x27;,
                        selector: &#x27;*&#x27;,
                        yui: {
                            name: name + langExt
                        }
                    };
                    res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                    res.source.pkg = store.getAppPkgMeta();
                    res.source.fs = store.makeResourceFSMeta(this.appRoot, &#x27;app&#x27;, &#x27;.&#x27;,
                        name + langExt + &#x27;.js&#x27;, true);
                    store.addResourceVersion(res);
                }
            }

            &#x2F;&#x2F; we can also make some fake resources for all yui
            &#x2F;&#x2F; modules that we might want to serve.
            this._precalcYUIResources();
        },


        &#x2F;**
         * Using AOP, this is called after the ResourceStore&#x27;s version.
         * We precompute the YUI configurations.
         * @method resolveResourceVersions
         * @return {nothing}
         *&#x2F;
        resolveResourceVersions: function() {
            &#x2F;&#x2F;console.log(&#x27;------------------------------------------- YUI resolveResourceVersions&#x27;);
            var me = this,
                store = this.get(&#x27;host&#x27;),
                m,
                mojit,
                mojits,
                langs;

            &#x2F;&#x2F; We need to wait until now to grab the appModulesDetails because we rely
            &#x2F;&#x2F; on the results of some of the other RS addons (specifically URL).
            function process(ress) {
                var r,
                    res;

                ress.sort(resourceSortByDepthTest);
                for (r = 0; r &lt; ress.length; r += 1) {
                    res = ress[r];
                    if (&#x27;client&#x27; !== res.affinity.affinity) {
                        &#x2F;&#x2F; appModulesDetails is used by getAppSeedFiles, which only matters for the client
                        continue;
                    }
                    if (!res.yui || !res.yui.name) {
                        continue;
                    }
                    if (me.appModulesDetails[res.yui.name]) {
                        if (me.appModulesDetails[res.yui.name].path !== res.source.fs.fullPath) {
                            Y.log(&#x27;YUI module collision for name=&#x27; + res.yui.name +
                                  &#x27;. Choosing:\n&#x27; + me.appModulesDetails[res.yui.name].path +
                                          &#x27; over\n&#x27; + res.source.fs.fullPath, &#x27;debug&#x27;, NAME);
                        }
                    } else {
                        me.appModulesDetails[res.yui.name] = store.makeStaticHandlerDetails(res);
                    }
                }
            }
            process(store.getResourceVersions({}));
            mojits = store.listAllMojits();
            mojits.push(&#x27;shared&#x27;);
            for (m = 0; m &lt; mojits.length; m += 1) {
                mojit = mojits[m];
                process(store.getResourceVersions({ mojit: mojit }));
            }

            langs = Object.keys(this.langs);
            &#x2F;&#x2F; we always want to make the no-lang version
            if (!this.langs[&#x27;&#x27;]) {
                langs.push(&#x27;&#x27;);
            }
            this._precalcLoaderMeta(langs);
        },


        &#x2F;**
         * Return the content for resources we make in makeResourceVersions().
         *
         * @method getResourceContent
         * @param {object} details static handling details
         * @param {function} callback callback used to return the resource content (or error)
         * @param {Error|undefined} callback.err Error that occurred, if any.
         *      If an error is given that the other two arguments will be undefined.
         * @param {Buffer} callback.content the contents of the resource
         * @param {Stat||null} callback.stat Stat object with details about the file on the filesystem
         *          Can be null if the resource doesn&#x27;t have a direct representation on the filesystem.
         * @return {undefined} nothing is returned, the results are returned via the callback
         *&#x2F;
        getResourceContent: function(res, callback) {
            var contents = res.name &amp;&amp; this.resContents[res.name];
            if (contents) {
                callback(null, new Buffer(contents, &#x27;utf8&#x27;), syntheticStat);
                return new Y.Do.Halt(null, null);
            }
        },


        &#x2F;**
         * Precomputes YUI modules resources, so that we don&#x27;t have to at runtime.
         * @private
         * @method _precalcYUIResources
         * @return {nothing}
         *&#x2F;
        _precalcYUIResources: function() {
            var store = this.get(&#x27;host&#x27;),
                name,
                modules,
                mimetype,
                charset,
                fullpath,
                Ysandbox;

            if (!this.staticHandling.serveYUIFromAppOrigin) {
                &#x2F;&#x2F; this should helps with the memory consumption
                &#x2F;&#x2F; by avoiding serving YUI Core modules, and instead
                &#x2F;&#x2F; getting those modules from CDN.
                return;
            }

            Ysandbox = yuiSandboxFactory
                .getYUI(this.yuiConfig.filter)(Y.merge(this.yuiConfig));

            &#x2F;&#x2F; used to find the the modules in YUI itself
            Ysandbox.use(&#x27;loader&#x27;);
            modules = (new Ysandbox.Loader(Ysandbox.config)).moduleInfo || {};

            for (name in modules) {
                if (modules.hasOwnProperty(name)) {
                    &#x2F;&#x2F; faking a RS object for the sake of simplicity
                    fullpath = libpath.join(__dirname,
                        &#x27;..&#x2F;..&#x2F;..&#x2F;..&#x2F;node_modules&#x2F;yui&#x27;, modules[name].path);
                    mimetype = libmime.lookup(fullpath);
                    charset  = libmime.charsets.lookup(mimetype);

                    modules[name] = store.makeStaticHandlerDetails({
                        type: &#x27;yui-module&#x27;,
                        name: name,
                        url: libutil.webpath(this.staticPrefix, &#x27;yui&#x27;, modules[name].path),
                        path: modules[name].path,
                        source: {
                            fs: {
                                fullPath: fullpath
                            }
                        },
                        mime: {
                            type: mimetype,
                            charset: charset
                        }
                    });
                }
            }
            this.yuiModulesDetails = modules;
        },

        &#x2F;**
         * Precomputes YUI loader metadata, so that we don&#x27;t have to at runtime.
         * @private
         * @method _precalcLoaderMeta
         * @param {array} langs array of languages for which to compute YUI loader metadata
         * @return {nothing}
         *&#x2F;
        _precalcLoaderMeta: function(langs) {
            &#x2F;&#x2F;console.log(&#x27;------------------------------------------- YUI _precalcLoaderMeta&#x27;);
            var store = this.get(&#x27;host&#x27;),
                lang,
                Ysandbox,
                modules_config,
                Ysanbdox,
                loader,
                resolved,
                appMetaData = {
                    base: {},
                    full: {}
                },
                yuiMetaData = {
                    base: {},
                    full: {}
                },
                expanded_modules = {}, &#x2F;&#x2F; expanded meta (including fullpaths)
                modules = {},          &#x2F;&#x2F; regular meta  (a la loader-yui3)
                conditions = {},       &#x2F;&#x2F; hash to store conditional functions
                name,
                i,
                l;

            Ysandbox = yuiSandboxFactory
                .getYUI(this.yuiConfig.filter)(Y.merge(this.yuiConfig));

            modules_config = this.getModulesConfig(&#x27;client&#x27;, false).modules;
            Ysandbox.applyConfig({
                modules: Ysandbox.merge({}, modules_config),
                useSync: true
            });
            Ysandbox.use(&#x27;loader&#x27;);

            &#x2F;&#x2F; using the loader at the server side to compute the loader metadata
            &#x2F;&#x2F; to avoid loading the whole thing on demand.
            loader = new Ysandbox.Loader(Ysandbox.merge(Ysandbox.config, {
                require: Ysandbox.Object.keys(modules_config)
            }));
            resolved = loader.resolve(true);

            &#x2F;&#x2F; we need to copy, otherwise the datastructures that Y.loader holds
            &#x2F;&#x2F; onto get mixed with our changes, and Y.loader gets confused
            resolved = Y.mojito.util.copy(resolved);

            this._processMeta(resolved.jsMods,  modules, expanded_modules, conditions, modules_config);
            this._processMeta(resolved.cssMods, modules, expanded_modules, conditions, modules_config);

            for (i = 0; i &lt; langs.length; i += 1) {
                lang = langs[i] || &#x27;*&#x27;;

                appMetaData.base[lang] = {};
                appMetaData.full[lang] = {};
                yuiMetaData.base[lang] = {};
                yuiMetaData.full[lang] = {};

                for (name in expanded_modules) {
                    if (expanded_modules.hasOwnProperty(name)) {
                        if (expanded_modules[name].owner &amp;&amp;
                                !expanded_modules[expanded_modules[name].owner]) {
                            &#x2F;&#x2F; if there is not a module corresponding with the lang pack
                            &#x2F;&#x2F; that means the controller doesn&#x27;t have client affinity,
                            &#x2F;&#x2F; in that case, we don&#x27;t need to ship it.
                            continue;
                        }
                        if ((lang === &#x27;*&#x27;) ||
                                (expanded_modules[name].langPack === &#x27;*&#x27;) ||
                                    (!expanded_modules[name].langPack) ||
                                            (lang === expanded_modules[name].langPack)) {

                            &#x2F;&#x2F; we want to separate modules into different buckets
                            &#x2F;&#x2F; to be able to support groups in loader config
                            if (modules_config[name]) {
                                appMetaData.base[lang][name] = modules[name];
                                appMetaData.full[lang][name] = expanded_modules[name];
                            } else {
                                yuiMetaData.base[lang][name] = modules[name];
                                yuiMetaData.full[lang][name] = expanded_modules[name];
                            }
                        }
                    }
                }

                appMetaData.base[lang] = JSON.stringify(appMetaData.base[lang]);
                appMetaData.full[lang] = JSON.stringify(appMetaData.full[lang]);
                yuiMetaData.base[lang] = JSON.stringify(yuiMetaData.base[lang]);
                yuiMetaData.full[lang] = JSON.stringify(yuiMetaData.full[lang]);

                for (name in conditions) {
                    if (conditions.hasOwnProperty(name)) {
                        appMetaData.base[lang] = appMetaData.base[lang]
                            .replace(&#x27;&quot;{&#x27; + name + &#x27;}&quot;&#x27;, conditions[name]);
                        appMetaData.full[lang] = appMetaData.full[lang]
                            .replace(&#x27;&quot;{&#x27; + name + &#x27;}&quot;&#x27;, conditions[name]);
                        yuiMetaData.base[lang] = yuiMetaData.base[lang]
                            .replace(&#x27;&quot;{&#x27; + name + &#x27;}&quot;&#x27;, conditions[name]);
                        yuiMetaData.full[lang] = yuiMetaData.full[lang]
                            .replace(&#x27;&quot;{&#x27; + name + &#x27;}&quot;&#x27;, conditions[name]);
                    }
                }
            } &#x2F;&#x2F; for each lang

            this.resContents[&#x27;loader-app&#x27;] = MODULE_TEMPLATES[&#x27;loader-app&#x27;];

            for (l = 0; l &lt; langs.length; l += 1) {
                lang = langs[l] || &#x27;&#x27;;

                for (i = 0; i &lt; MODULE_PER_LANG.length; i += 1) {

                    name = MODULE_PER_LANG[i];
                    &#x2F;&#x2F; populating the internal cache using name+lang as the key
                    this.resContents[([name, lang].join(&#x27;-&#x27;))] =
                        this._produceMeta(name, lang || &#x27;*&#x27;, appMetaData, yuiMetaData);

                }

            }
        },


        &#x2F;**
         * @private
         * @method _processMeta
         * @param {object} resolvedMods resolved module metadata, from Y.Loader.resolve()
         * @param {object} modules regular YUI module metadata (ala loader-yui3)
         * @param {object} expanded_modules YUI module metadata that include details such as fullpaths. This parameter is populated by this method.
         * @param {object} conditions store of conditional functions. This parameter is populated by this method.
         * @param {object} appModules a hash table with the modules that are part of the app, use to correct paths when needed.
         * @return {nothing}
         *&#x2F;
        _processMeta: function(resolvedMods, modules, expanded_modules, conditions, appModules) {
            var m,
                l,
                i,
                module,
                name,
                mod,
                mod1,
                lang,
                bundle,
                intlmodules = [];

            for (m in resolvedMods) {
                if (resolvedMods.hasOwnProperty(m)) {
                    module = resolvedMods[m];

                    mod = name = module.name;

                    bundle = name.indexOf(&#x27;lang&#x2F;&#x27;) === 0;
                    lang = bundle &amp;&amp; REGEX_LOCALE.exec(name);
                    if (lang) {
                        mod = mod.slice(0, lang.index); &#x2F;&#x2F; eg. lang&#x2F;foo_en-US -&gt; lang&#x2F;foo
                        lang = lang[1];
                        mod1 = mod.split(&quot;&#x2F;&quot;);
                        if (intlmodules.indexOf(mod1[1]) === -1) {
                            intlmodules.push(mod1[1]);
                        }
                        &#x2F;&#x2F; TODO: validate lang
                    }
                    mod = bundle ? mod.slice(5) : mod; &#x2F;&#x2F; eg. lang&#x2F;foo -&gt; foo

                    &#x2F;&#x2F; language manipulation
                    &#x2F;&#x2F; TODO: this routine is very restrictive, and we might want to
                    &#x2F;&#x2F; make it optional later on.
                    if (module.lang) {
                        module.lang = [&#x27;{langToken}&#x27;];
                    }
                    if (bundle) {
                        module.owner = mod;
                        &#x2F;&#x2F; applying some extra optimizations
                        module.langPack = lang || &#x27;*&#x27;;
                        module.intl = true;
                        module.expanded_map = undefined;
                    }

                    if (module.condition &amp;&amp; module.condition.test) {
                        conditions[module.name] = module.condition.test.toString();
                        module.condition.test = &quot;{&quot; + module.name + &quot;}&quot;;
                    }

                    if (appModules[module.name]) {
                        &#x2F;&#x2F; getting the last portion of the url which
                        &#x2F;&#x2F; is the important part for loader to make
                        &#x2F;&#x2F; combo urls shorter
                        module.path = module.path.split(&#x27;&#x2F;&#x27;).pop();
                        &#x2F;&#x2F; for yui core modules we just let loader
                        &#x2F;&#x2F; do its thing
                    }

                    modules[module.name] = {};
                    if (module.type === &#x27;css&#x27;) {
                        modules[module.name].type = &#x27;css&#x27;;
                    }
                    for (i = 0; i &lt; MODULE_META_ENTRIES.length; i += 1) {

                        if (MODULE_META_ENTRIES[i] === &#x27;path&#x27; &amp;&amp; module.intl) {
                            module[MODULE_META_ENTRIES[i]] =
                                &#x27;lang&#x2F;&#x27; + module[MODULE_META_ENTRIES[i]];
                        }
                        if (module[MODULE_META_ENTRIES[i]]) {
                            modules[module.name][MODULE_META_ENTRIES[i]] =
                                module[MODULE_META_ENTRIES[i]];
                        }
                    }

                    expanded_modules[module.name] = module;
                    for (i = 0; i &lt; MODULE_META_PRIVATE_ENTRIES.length; i += 1) {
                        module[MODULE_META_PRIVATE_ENTRIES[i]] = undefined;
                    }
                }
            }

            &#x2F;&#x2F;scan modules in resolvedMods, if a module is also listed in intlmodules,
            &#x2F;&#x2F;lang holder will be added to the module&#x27;s meta data.
            &#x2F;&#x2F;lang info will be plugged in later when _precalcLoaderMeta is called
            for (m in resolvedMods) {
                if (resolvedMods.hasOwnProperty(m)) {
                    module = resolvedMods[m];
                    if (intlmodules.indexOf(module.name) &gt; -1) {
                        modules[module.name].lang = [&#x27;{langToken}&#x27;];
                    }
                }
            }
        },


        &#x2F;**
         * Generates the final YUI metadata.
         * @private
         * @method _produceMeta
         * @param {string} name type of YUI metadata to return
         * @param {string} lang which language the metadata should be customized for
         * @param {object} appMetaData gathered YUI metadata for the application
         * @param {object} yuiMetaData gathered YUI metadata for YUI itself
         * @return {string} the requested YUI metadata
         *&#x2F;
        _produceMeta: function(name, lang, appMetaData, yuiMetaData) {
            var token = &#x27;&#x27;,
                path  = &#x27;&#x27;;

            if (lang) {
                token = &#x27;&quot;&#x27; + lang + &#x27;&quot;&#x27;;
                path  = &#x27;_&#x27; + lang;
            } else {
                lang = &#x27;*&#x27;;
            }

            &#x2F;&#x2F; module definition definitions
            return MODULE_TEMPLATES[name]
                .replace(&#x27;{app-base}&#x27;, appMetaData.base[lang] || appMetaData.base[&#x27;*&#x27;])
                .replace(&#x27;{app-resolved}&#x27;, appMetaData.full[lang] || appMetaData.full[&#x27;*&#x27;])
                .replace(&#x27;{yui-base}&#x27;, yuiMetaData.base[lang] || yuiMetaData.base[&#x27;*&#x27;])
                .replace(&#x27;{yui-resolved}&#x27;, yuiMetaData.full[lang] || yuiMetaData.full[&#x27;*&#x27;])
                .replace(REGEX_LANG_TOKEN, token)
                .replace(REGEX_LANG_PATH, path);
        },


        &#x2F;**
         * Precomputes a set of dependencies.
         * @private
         * @method _precomputeYUIDependencies
         * @param {string} lang YUI language code
         * @param {string} env runtime environment (either &#x60;client&#x60;, or &#x60;server&#x60;)
         * @param {string} mojit name of the mojit
         * @param {object} modules YUI module metadata
         * @param {object} required lookup hash of YUI module names that are required
         * @param {boolean} forceYLoader whether to force the use of Y.Loader
         * @return {object} precomputed (and sorted) module dependencies
         *&#x2F;
        _precomputeYUIDependencies: function(lang, env, mojit, modules, required, forceYLoader) {
            var loader,
                m,
                module,
                originalYUAnodejs,
                info,
                warn,
                sortedPaths = {};

            &#x2F;&#x2F; We don&#x27;t actually need the full list, just the required modules.
            &#x2F;&#x2F; YUI.Loader() will do the rest at runtime.
            if (!forceYLoader) {
                for (module in required) {
                    if (required.hasOwnProperty(module) &amp;&amp; modules[module]) {
                        sortedPaths[module] = modules[module].fullpath;
                    }
                }
                return {
                    sorted: Object.keys(sortedPaths),
                    paths: sortedPaths
                };
            }

            &#x2F;&#x2F; HACK
            &#x2F;&#x2F; We need to clear YUI&#x27;s cached dependencies, since there&#x27;s no
            &#x2F;&#x2F; guarantee that the previously calculated dependencies have been done
            &#x2F;&#x2F; using the same context as this calculation.
            YUI.Env._renderedMods = undefined;

            &#x2F;&#x2F; Trick the loader into thinking it&#x27;s -not- running on nodejs.
            &#x2F;&#x2F; This is the official way to do it.
            originalYUAnodejs = Y.UA.nodejs;
            Y.UA.nodejs = (&#x27;server&#x27; === env);

            &#x2F;&#x2F; Use ignoreRegistered here instead of the old &#x60;YUI.Env._renderedMods = undefined;&#x60; hack
            loader = new Y.Loader({ ignoreRegistered: true });
            &#x2F;&#x2F; Only override the default if it&#x27;s required
            if (this.yuiConfig.base) {
                loader.base = this.yuiConfig.base;
            }

            loader.addGroup({modules: modules}, mojit);
            loader.calculate({required: required});

            Y.UA.nodejs = originalYUAnodejs;

            for (m = 0; m &lt; loader.sorted.length; m += 1) {
                module = loader.sorted[m];
                info = loader.moduleInfo[module];
                if (info) {
                    &#x2F;&#x2F; modules with &quot;nodejs&quot; in their name are tweaks on other modules
                    if (&#x27;client&#x27; === env &amp;&amp; module.indexOf(&#x27;nodejs&#x27;) !== -1) {
                        continue;
                    }
                    sortedPaths[module] = info.fullpath || loader._url(info.path);
                }
            }

            &#x2F;&#x2F; log warning if server mojit has dom dependency
            if (&#x27;server&#x27; === env) {
                warn = Y.Object.keys(sortedPaths).join(&#x27; &#x27;).match(WARN_SERVER_MODULES);
                if (warn) {
                    Y.log(&#x27;your mojit &quot;&#x27; + mojit + &#x27;&quot; has a server affinity and these client-related deps: &#x27; + warn.join(&#x27;, &#x27;), &#x27;WARN&#x27;, NAME);
                    Y.log(&#x27;Mojito may be unable to start, unless you have provided server-side DOM&#x2F;host-object suppport&#x27;, &#x27;WARN&#x27;, NAME);
                }
            }

            return {
                sorted: loader.sorted,
                paths: sortedPaths
            };
        },


        &#x2F;**
         * Generates the YUI configuration for the resource.
         * @private
         * @method _makeYUIModuleConfig
         * @param {string} env runtime environment (either &#x60;client&#x60;, or &#x60;server&#x60;)
         * @param {object} res the resource metadata
         * @return {object} the YUI configuration for the module
         *&#x2F;
        _makeYUIModuleConfig: function(env, res) {
            var config = {
                requires: (res.yui.meta &amp;&amp; res.yui.meta.requires) || []
            };
            if (&#x27;client&#x27; === env) {
                &#x2F;&#x2F; using relative path since the loader will do the rest
                config.path = res.url;
            } else {
                config.fullpath = res.source.fs.fullPath;
            }
            return config;
        },


        &#x2F;**
         * If the resource is a YUI module, augments its metadata with metadata
         * about the YUI module.
         * @private
         * @method _captureYUIModuleDetails
         * @param {object} res resource metadata
         * @param {object} runSandbox if passed, the function in the module
         *      will be called using this parameter as the YUI sandbox
         * @return {nothing}
         *&#x2F;
        _captureYUIModuleDetails: function(res, runSandbox) {
            var file,
                ctx,
                yui = {};
            file = libfs.readFileSync(res.source.fs.fullPath, &#x27;utf8&#x27;);
            &#x2F;&#x2F; setting up the fake YUI before executing the file
            contextForRunInContext.YUI = {
                ENV: {},
                config: {},
                use: function() {},
                add: function(name, fn, version, meta) {
                    yui.name = name;
                    yui.version = version;
                    yui.meta = meta || {};
                    if (!yui.meta.requires) {
                        yui.meta.requires = [];
                    }
                    if (runSandbox) {
                        try {
                            fn(runSandbox, yui.name);
                        } catch (e) {
                            Y.log(&#x27;failed to run javascript file &#x27; + res.source.fs.fullPath + &#x27;\n&#x27; + e.message, &#x27;error&#x27;, NAME);
                        }
                    }
                }
            };
            try {
                libvm.runInContext(file, contextForRunInContext, res.source.fs.fullPath);
            } catch (e) {
                yui = null;
                Y.log(&#x27;failed to parse javascript file &#x27; + res.source.fs.fullPath + &#x27;\n&#x27; + e.message, &#x27;error&#x27;, NAME);
            }
            if (yui) {
                res.yui = Y.merge(res.yui || {}, yui);
            }
        }


    });
    Y.namespace(&#x27;mojito.addons.rs&#x27;);
    Y.mojito.addons.rs.yui = RSAddonYUI;

}, &#x27;0.0.1&#x27;, { requires: [&#x27;plugin&#x27;, &#x27;oop&#x27;, &#x27;loader-base&#x27;, &#x27;mojito-util&#x27;]});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>

<!-- SpaceID=0 robot -->

<!-- VER-3.0.246810 -->
<!-- p2.ydn.bf1.yahoo.com uncompressed/chunked Fri Oct  4 11:13:28 PDT 2013 -->
