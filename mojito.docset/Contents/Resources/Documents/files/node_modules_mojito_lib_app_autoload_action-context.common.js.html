<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;mojito&#x2F;lib&#x2F;app&#x2F;autoload&#x2F;action-context.common.js - Mojito API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;developer.yahoo.com&#x2F;cocktails&#x2F;mojito&#x2F;api&#x2F;assets&#x2F;img&#x2F;mojito-logo-white-bkg.png" title="Mojito API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.7.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ActionContext.html">ActionContext</a></li>
            
                <li><a href="..&#x2F;classes/Analytics.common.html">Analytics.common</a></li>
            
                <li><a href="..&#x2F;classes/Assets.common.html">Assets.common</a></li>
            
                <li><a href="..&#x2F;classes/Composite.common.html">Composite.common</a></li>
            
                <li><a href="..&#x2F;classes/Config.common.html">Config.common</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.client.html">Cookie.client</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.server.html">Cookie.server</a></li>
            
                <li><a href="..&#x2F;classes/Data.common.data.html">Data.common.data</a></li>
            
                <li><a href="..&#x2F;classes/Data.common.pageData.html">Data.common.pageData</a></li>
            
                <li><a href="..&#x2F;classes/Deploy.server.html">Deploy.server</a></li>
            
                <li><a href="..&#x2F;classes/Helpers.common.html">Helpers.common</a></li>
            
                <li><a href="..&#x2F;classes/Http.server.html">Http.server</a></li>
            
                <li><a href="..&#x2F;classes/Intl.common.html">Intl.common</a></li>
            
                <li><a href="..&#x2F;classes/Meta.common.html">Meta.common</a></li>
            
                <li><a href="..&#x2F;classes/Model.Vanilla.html">Model.Vanilla</a></li>
            
                <li><a href="..&#x2F;classes/Models.common.html">Models.common</a></li>
            
                <li><a href="..&#x2F;classes/MojitoDispatcher.html">MojitoDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/MojitoPerf.html">MojitoPerf</a></li>
            
                <li><a href="..&#x2F;classes/MojitoRouter.html">MojitoRouter</a></li>
            
                <li><a href="..&#x2F;classes/MojitProxy.html">MojitProxy</a></li>
            
                <li><a href="..&#x2F;classes/OutputBuffer.html">OutputBuffer</a></li>
            
                <li><a href="..&#x2F;classes/OutputHandler.html">OutputHandler</a></li>
            
                <li><a href="..&#x2F;classes/Params.common.html">Params.common</a></li>
            
                <li><a href="..&#x2F;classes/Partial.common.html">Partial.common</a></li>
            
                <li><a href="..&#x2F;classes/ResourceStore.server.html">ResourceStore.server</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonConfig.html">RSAddonConfig</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonDispatchHelper.html">RSAddonDispatchHelper</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonMime.html">RSAddonMime</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonSelector.html">RSAddonSelector</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonUrl.html">RSAddonUrl</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonYUI.html">RSAddonYUI</a></li>
            
                <li><a href="..&#x2F;classes/Url.common.html">Url.common</a></li>
            
                <li><a href="..&#x2F;classes/Y.mojito.Client.html">Y.mojito.Client</a></li>
            
                <li><a href="..&#x2F;classes/Y.mojito.lib.REST.html">Y.mojito.lib.REST</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ActionContext.html">ActionContext</a></li>
            
                <li><a href="..&#x2F;modules/ActionContextAddon.html">ActionContextAddon</a></li>
            
                <li><a href="..&#x2F;modules/app.html">app</a></li>
            
                <li><a href="..&#x2F;modules/CommonLibs.html">CommonLibs</a></li>
            
                <li><a href="..&#x2F;modules/Data.common.html">Data.common</a></li>
            
                <li><a href="..&#x2F;modules/model-vanilla.html">model-vanilla</a></li>
            
                <li><a href="..&#x2F;modules/mojito-perf.html">mojito-perf</a></li>
            
                <li><a href="..&#x2F;modules/MojitoClient.html">MojitoClient</a></li>
            
                <li><a href="..&#x2F;modules/MojitoHooks.html">MojitoHooks</a></li>
            
                <li><a href="..&#x2F;modules/OutputBuffer.html">OutputBuffer</a></li>
            
                <li><a href="..&#x2F;modules/ResourceStore.html">ResourceStore</a></li>
            
                <li><a href="..&#x2F;modules/ResourceStoreAddon.html">ResourceStoreAddon</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;mojito&#x2F;lib&#x2F;app&#x2F;autoload&#x2F;action-context.common.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2011-2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 *&#x2F;


&#x2F;*jslint anon:true, nomen:true*&#x2F;
&#x2F;*global YUI, setTimeout, clearTimeout*&#x2F;


&#x2F;**
 * The Action Context is a key part of the Mojito framework. The &lt;em&gt;ac&lt;&#x2F;em&gt;,
 * for short, gives you access to the frameworks features from within a
 * controller function. The ac is an abstraction that allows you to execute
 * mojit actions within either a server or client context.
 * @module ActionContext
 *&#x2F;
YUI.add(&#x27;mojito-action-context&#x27;, function(Y, NAME) {

    &#x27;use strict&#x27;;

    &#x2F;**
     * This dispatch function is called one time per Mojito execution. It
     * creates a contextualized Y instance for all further internal dispatches
     * to use. It also creates the ActionContext for the mojit.
     *
     * The command has three main parts:  the &quot;instance&quot;, the &quot;context&quot;, and the
     * &quot;params&quot;.
     * &lt;pre&gt;
     *  command: {
     *      instance: ...see below...
     *      context: ...see below...
     *      params: ...see below...
     *  }
     * &lt;&#x2F;pre&gt;
     *
     * The &quot;instance&quot; is a partial instance with details of the mojit instance.
     * See &#x60;ServerStore.expandInstance()&#x60; for details of the structure and which
     * fields are required.
     *
     * The &quot;context&quot; is the request context.  It is built by the
     * &quot;contextualizer&quot; middleware.
     *
     * The &quot;params&quot; is a structured set of parameters to pass to the mojit.
     * &lt;pre&gt;
     *  params: {
     *      route: {},
     *      url: {},
     *      body: {},
     *      file: {},
     *      ...
     *  }
     * &lt;&#x2F;pre&gt;
     *
     * &lt;pre&gt;
     * adapter: {
     *      flush: function(data, meta){},
     *      done: function(data, meta){},
     *      error: function(err){}
     * }
     * &lt;&#x2F;pre&gt;
     * @method dispatch
     * @param {map} command the &quot;command&quot; describing how to dispatch the mojit.
     *     See above.
     * @param {object} adapter the output adapter to pass to the mojit. See
     *     above.
     * @deprecated Use &#x27;ac._dispatch()&#x27; instead. See https:&#x2F;&#x2F;github.com&#x2F;yahoo&#x2F;mojito&#x2F;blob&#x2F;develop&#x2F;DEPRECATIONS.md
     * for details.
     *&#x2F;
     &#x2F;**
     * This _dispatch function is called one time per Mojito execution. It
     * creates a contextualized Y instance for all further internal dispatches
     * to use. It also creates the ActionContext for the mojit.
     *
     * The command has three main parts:  the &quot;instance&quot;, the &quot;context&quot;, and the
     * &quot;params&quot;.
     * &lt;pre&gt;
     *  command: {
     *      instance: ...see below...
     *      context: ...see below...
     *      params: ...see below...
     *  }
     * &lt;&#x2F;pre&gt;
     *
     * The &quot;instance&quot; is a partial instance with details of the mojit instance.
     * See &#x60;ServerStore.expandInstance()&#x60; for details of the structure and which
     * fields are required.
     *
     * The &quot;context&quot; is the request context.  It is built by the
     * &quot;contextualizer&quot; middleware.
     *
     * The &quot;params&quot; is a structured set of parameters to pass to the mojit.
     * &lt;pre&gt;
     *  params: {
     *      route: {},
     *      url: {},
     *      body: {},
     *      file: {},
     *      ...
     *  }
     * &lt;&#x2F;pre&gt;
     *
     * &lt;pre&gt;
     * adapter: {
     *      flush: function(data, meta){},
     *      done: function(data, meta){},
     *      error: function(err){}
     * }
     * &lt;&#x2F;pre&gt;
     * @method _dispatch
     * @param {map} command the &quot;command&quot; describing how to dispatch the mojit.
     *     See above.
     * @param {object} adapter the output adapter to pass to the mojit. See
     *     above.
     *&#x2F;


    var CHARSET = &#x27;charset=utf-8&#x27;,
        &#x2F;&#x2F; the functions this core addon is going to attach to the
        &#x2F;&#x2F; ActionContext
        flush,
        done,
        error,

        &#x2F;&#x2F; serializer container
        serializer,
        CACHE = { renderers: { } };

    function sanitizeChildren(children) {
        if (!Y.Lang.isObject(children)) {
            return children;
        }
        Y.Object.each(children, function(v, k) {
            &#x2F;&#x2F; We don&#x27;t want child params to be included within a mojit&#x27;s
            &#x2F;&#x2F; configuration, because it can leak implemenation details out to
            &#x2F;&#x2F; other execution environments. For example, the client runtime
            &#x2F;&#x2F; does not need to have the parameters of the mojits that were used
            &#x2F;&#x2F; to construct the initial client DOM.
            children[k].params = undefined;
        });
        return children;
    }


    function sanitizeConfigCopy(cfg) {
        var copy;
        if (!Y.Lang.isObject(cfg)) {
            return cfg;
        }
        copy = Y.mojito.util.copy(cfg);
        copy.children = sanitizeChildren(copy.children);
        return copy;
    }


    function attachChildViewIdsToMetaChildren(children, binders) {
        if (!children) {
            return;
        }
        Y.Object.each(binders, function(binderData, viewId) {
            Y.Object.each(children, function(childData) {
                if (binderData.instanceId === childData.instanceId) {
                    childData.viewId = viewId;
                }
            });
        });
    }


    serializer = {
        &#x2F;*
         * @method json
         * @private
         * @param {object} data
         * @param {object} meta
         * @return {string}
         *&#x2F;
        json: function(data, meta) {
            meta.http.headers[&#x27;content-type&#x27;] = [&#x27;application&#x2F;json; &#x27; + CHARSET];

            try {
                return Y.JSON.stringify(data);
            } catch (err) {
                throw new Error(&#x27;Expected JSON data, but there was a parse error&#x27; +
                        &#x27; on the string: \&quot;&#x27; + data);
            }

        },
        &#x2F;*
         * @method xml
         * @private
         * @param {object} data
         * @param {object} meta
         * @return {string}
         *&#x2F;
        xml: function(data, meta) {
            &#x2F;&#x2F; A dirty XML function I found on the interwebs
            function simpleXml(js, wraptag) {
                if (js instanceof Object) {
                    return simpleXml(Y.Object.keys(js).map(function(key) {
                        return simpleXml(js[key], key);
                    }).join(&#x27;\n&#x27;), wraptag);
                }

                return ((wraptag) ? &#x27;&lt;&#x27; + wraptag + &#x27;&gt;&#x27; : &#x27;&#x27;) + js +
                    ((wraptag) ? &#x27;&lt;&#x2F;&#x27; + wraptag + &#x27;&gt;&#x27; : &#x27;&#x27;
                        );
            }

            meta.http.headers[&#x27;content-type&#x27;] = [&#x27;application&#x2F;xml; &#x27; + CHARSET];
            if (Y.Lang.isObject) {
                try {
                    return simpleXml(data, &#x27;xml&#x27;);
                } catch (err) {
                    throw new Error(&#x27;Expected XML data, but there was a parse&#x27; +
                            &#x27; error on the string: \&quot;&#x27; + err.message);
                }
            }

            return &#x27;&#x27;;
        }
    };


    &#x2F;**
     * Mixes all the Action Context addons into the Action Context
     * @private
     * @method attachActionContextAddons
     * @param {Array} addons The action context addons.
     * @param {object} command The command object.
     * @param {object} adapter The output adapter.
     * @param {Y.mojito.ActionContext} ac The action context.
     * @param {ResourceStore} store the resource store
     *&#x2F;
    function attachActionContextAddons(addons, command, adapter, ac, store) {

        var i,
            addon,
            addonName,
            acAddons = command.instance.acAddons || [];
        &#x2F;&#x2F; HookSystem::StartBlock
        Y.mojito.hooks.hook(&#x27;attachActionContext&#x27;, adapter.hook, &#x27;start&#x27;, command);
        &#x2F;&#x2F; HookSystem::EndBlock

        for (i = 0; i &lt; acAddons.length; i += 1) {
            addonName = acAddons[i];
            if (addons[addonName]) {
                addon = new addons[addonName](command, adapter, ac);
                if (addon.namespace) {
                    ac[addon.namespace] = addon;
                    &#x2F;&#x2F; TODO: this is a big hack to pass the store reference
                    &#x2F;&#x2F; into the addon without changing the signature of ctor,
                    &#x2F;&#x2F; instead we should pass an object with all the stuff that
                    &#x2F;&#x2F; an addon will need as part of the ctor.
                    if (Y.Lang.isFunction(addon.setStore)) {
                        addon.setStore(store);
                    }
                }
            } else {
                Y.log(&#x27;[&#x27; + addonName + &#x27;] addon was not found for mojit &#x27; + command.instance.type,
                    &#x27;warn&#x27;, NAME);
            }
        }

        &#x2F;&#x2F; HookSystem::StartBlock
        Y.mojito.hooks.hook(&#x27;attachActionContext&#x27;, adapter.hook, &#x27;end&#x27;, command);
        &#x2F;&#x2F; HookSystem::EndBlock

    }


    &#x2F;**
     * The main point of entry for all mojits into Mojito. The Action Context is
     * passed to every mojit action during execution, either on the client or
     * server. This object is the API into Mojito, can can have many plugins
     * attached the provide extra functionality.
     * @class ActionContext
     *&#x2F;
    function ActionContext(opts) {

        var controller = opts.controller,
            command = opts.command,
            store = opts.store,
            actionFunction,
            error,
            my = this;

        &#x2F;&#x2F; HookSystem::StartBlock
        Y.mojito.hooks.hook(&#x27;actionContext&#x27;, opts.adapter.hook, &#x27;start&#x27;, my, opts);
        &#x2F;&#x2F; HookSystem::EndBlock

        &#x2F;&#x2F; It&#x27;s possible to setup a route that calls &quot;foo.&quot;, which means that
        &#x2F;&#x2F; the default action in the instance should be used instead.
        if (!command.action) {
            command.action = command.instance.action || &#x27;index&#x27;;
        }

        this.action = command.action;
        this.type = command.instance.type;
        this.context = command.context;
        this.dispatcher = opts.dispatcher;
        actionFunction = this.action;

        &#x2F;&#x2F; These should not be on the ac object
        this.command = command;
        this.instance = command.instance;
        this._adapter = opts.adapter;

        &#x2F;&#x2F; Create a function which will properly delegate to the dispatcher to
        &#x2F;&#x2F; perform the actual processing.
        this._dispatch = function(command, adapter) {
            return my.dispatcher.dispatch(command, adapter);
        };

        attachActionContextAddons(Y.mojito.addons.ac, command, opts.adapter, this, store);

        &#x2F;&#x2F; Check if the controller has the requested action
        if (!Y.Lang.isFunction(controller[actionFunction])) {
            &#x2F;&#x2F; If the action is not found try the &#x27;__call&#x27; function
            if (Y.Lang.isFunction(controller.__call)) {
                actionFunction = &#x27;__call&#x27;;
            } else {
                &#x2F;&#x2F; If there is still no joy then die
                error = new Error(&quot;No method &#x27;&quot; + command.action + &quot;&#x27; on controller type &#x27;&quot; + command.instance.type + &quot;&#x27;&quot;);
                error.code = 404;
                throw error;
            }
        }

        &#x2F;&#x2F; HookSystem::StartBlock
        Y.mojito.hooks.hook(&#x27;actionContext&#x27;, opts.adapter.hook, &#x27;end1&#x27;, my, opts);
        &#x2F;&#x2F; HookSystem::EndBlock

        &#x2F;&#x2F; Reap the request&#x2F;ac process within the timeout. If ac.done or
        &#x2F;&#x2F; ac.error is invoked by user code prior to the time limit this
        &#x2F;&#x2F; timer will be cleared.
        if (this._adapter.page.staticAppConfig.actionTimeout) {
            this._timer = setTimeout(function() {
                var err,
                    msg = &#x27;Killing potential zombie context for Mojit type: &#x27; +
                        my.instance.type +
                        &#x27;, controller: &#x27; + my.instance.controller +
                        &#x27;, action: &#x27; + actionFunction;

                &#x2F;&#x2F; Clear the timer reference so our invocation of error()
                &#x2F;&#x2F; doesn&#x27;t try to clear it.
                my._timer = null;

                &#x2F;&#x2F; Create an HTTP Timeout error with controller&#x2F;action info.
                err = new Error(msg);
                err.code = 408;

                my.error(err);

                my.done = function() {
                    Y.log(&#x27;ac.done() called after timeout. results lost&#x27;, &#x27;warn&#x27;, NAME);
                };

            }, this._adapter.page.staticAppConfig.actionTimeout);
        }

        controller[actionFunction](this);

        &#x2F;&#x2F; HookSystem::StartBlock
        Y.mojito.hooks.hook(&#x27;actionContext&#x27;, opts.adapter.hook, &#x27;end2&#x27;, my, opts);
        &#x2F;&#x2F; HookSystem::EndBlock

    }

    ActionContext.prototype = {
        &#x2F;**
        * Returns data in the request and allows you to carry on execution.
        * @method flush
        * @param {object|string} data The data you want return by the request.
        * @param {object} meta Any meta-data required to service the request.
        *&#x2F;
        flush: function(data, meta) {
            return this.done(data, meta, true);
        },

        &#x2F;**
        * Returns data and closes the request.
        * @method done
        * @param {object|string} data The data you want return by the request.
        * @param {object} meta Any meta-data required to service the request.
        *&#x2F;
        done: function(data, meta, more) {

            &#x2F;&#x2F; If we have an active timer clear it immediately.
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }

            var callbackFunc = more ? &#x27;flush&#x27; : &#x27;done&#x27;,
                instance = this.command.instance,
                config = instance.config || {},
                context = this.command.context || {},
                adapter = this._adapter,
                page = adapter.page || {},
                action = this.command.action,
                mojitView,
                renderer = null,
                contentType,
                instanceData;

            &#x2F;&#x2F; TODO: optimize this. it is not needed if there is no binder
            &#x2F;&#x2F;       nor view name, but it is needed in 90ish % of the cases
            if (instance.data &amp;&amp; instance.data.toJSON) {
                instanceData = instance.data.toJSON();
            }

            &#x2F;&#x2F; HookSystem::StartBlock
            Y.mojito.hooks.hook(&#x27;actionContextDone&#x27;, adapter.hook, &#x27;start&#x27;, this);
            &#x2F;&#x2F; HookSystem::EndBlock

            if (Y.Lang.isString(meta)) {
                &#x2F;&#x2F; If the meta string is a serializer set it
                if (serializer[meta]) {
                    meta = {
                        serialize: meta
                    };
                } else {&#x2F;&#x2F; Otherwise we think it is a template name
                    meta = {
                        view: {name: meta}
                    };
                }
            }

            meta = meta || {};
            meta.assets = meta.assets || {};
            meta.assets.bottom = meta.assets.bottom || {};
            meta.assets.bottom.js = meta.assets.bottom.js || [];
            meta.http = meta.http || {};
            meta.http.code = meta.http.code || 200;
            meta.http.headers = meta.http.headers || {};
            meta.view = meta.view || {};

            &#x2F;&#x2F; Check to see we need to serialize the data
            if (meta.serialize &amp;&amp; serializer[meta.serialize]) {
                &#x2F;&#x2F; Warning: this metod can change the &quot;meta&quot; object
                data = serializer[meta.serialize].apply(this, [data, meta]);
                &#x2F;&#x2F; Once we are done, invalidate the &quot;serialize&quot; option so others don&#x27;t
                &#x2F;&#x2F; use it by mistake
                meta.serialize = undefined;
            }

            &#x2F;&#x2F; We want to know the view name, id, and binder used later so make sure
            &#x2F;&#x2F; &quot;meta&quot; is up-to-date
            meta.view.name = meta.view.name || action;
            &#x2F;&#x2F; TODO: Use a different binder
            meta.view.binder = meta.view.binder || meta.view.name;
            mojitView = instance.views[meta.view.name];
            if (!meta.view.id) {
                meta.view.id = Y.guid();
                &#x2F;&#x2F;DEBUGGING:  meta.view.id += &#x27;-viewId-&#x27; +
                &#x2F;&#x2F;  this.command.instance.type + &#x27;-&#x27; + this.command.action;
            }

            &#x2F;&#x2F; If we are given &quot;meta.view[&#x27;content-path&#x27;]&quot; use it over what we got
            &#x2F;&#x2F; from &quot;instance.views&quot;
            if (mojitView &amp;&amp; meta.view[&#x27;content-path&#x27;]) {
                mojitView[&#x27;content-path&#x27;] = meta.view[&#x27;content-path&#x27;];
            }

            &#x2F;&#x2F; If we are given &quot;meta.view[&#x27;engine&#x27;]&quot; use it over what we got from
            &#x2F;&#x2F; &quot;instance.views&quot;
            if (mojitView &amp;&amp; meta.view.engine) {
                mojitView.engine = meta.view.engine;
            }
            if (mojitView &amp;&amp; mojitView.assets) {
                meta.assets = Y.mojito.util.metaMerge(meta.assets, mojitView.assets);
            }

            meta.assets = Y.mojito.util.metaMerge(meta.assets, config.assets || {});
            &#x2F;&#x2F; Here we ask each &quot;thing&quot; attached to the AC if it wants to add view
            &#x2F;&#x2F; &quot;meta&quot;
            Y.Object.each(this, function(item) {
                if (item &amp;&amp; Y.Lang.isFunction(item.mergeMetaInto)) {
                    item.mergeMetaInto(meta);
                }
            });

            contentType = meta.http.headers[&#x27;content-type&#x27;];

            attachChildViewIdsToMetaChildren(meta.children, meta.binders);

            if (!meta.binders) {
                meta.binders = {};
            }

            &#x2F;&#x2F; Don&#x27;t clobber an existing meta.binders[meta.view.id] entry
            if (!meta.binders[meta.view.id]) {
                &#x2F;&#x2F; do not add binder meta if there is not binder available
                if (meta.view.binder &amp;&amp; instance.binders &amp;&amp; instance.binders[meta.view.binder]) {
                    meta.binders[meta.view.id] = {
                        base: instance.base,
                        name: instance.binders[meta.view.binder], &#x2F;&#x2F; YUI Module name of the Binder
                        action: action,
                        type: instance.type,
                        viewId: meta.view.id,
                        instanceId: instance.instanceId,
                        &#x2F;&#x2F; We don&#x27;t use the actual config&#x27;s children object, because
                        &#x2F;&#x2F; that might not have been what was actually dispatched. We get
                        &#x2F;&#x2F; the actual children config that was dispatched through the
                        &#x2F;&#x2F; meta object.
                        children: sanitizeChildren(meta.children || config.children),
                        &#x2F;&#x2F; adding instance data model into the binder map to rehydrated in the client
                        data: instanceData
                    };
                    if (instance.proxied) {
                        &#x2F;&#x2F; direct support for proxied children
                        meta.binders[meta.view.id].proxied =
                            sanitizeChildren({proxied: instance.proxied}).proxied;
                    }

                }
            }

            &#x2F;*
             * Here we provide an easy way to return a string
             * data == &#x27;a string of chars&#x27;
             *&#x2F;
            if (Y.Lang.isString(data)) {
                &#x2F;&#x2F; if the user didn&#x27;t provided a content type, we&#x27;ll make it plain
                &#x2F;&#x2F; text
                if (!contentType) {
                    meta.http.headers[&#x27;content-type&#x27;] = [&#x27;text&#x2F;plain; &#x27; + CHARSET];
                }
                &#x2F;&#x2F;Y.log(&#x27;pushing to native adapter&#x27;, &#x27;info&#x27;, NAME);
                adapter[callbackFunc](data, meta);

                &#x2F;&#x2F; HookSystem::StartBlock
                Y.mojito.hooks.hook(&#x27;actionContextDone&#x27;, adapter.hook, &#x27;end1&#x27;, this);
                &#x2F;&#x2F; HookSystem::EndBlock

                return;
            }

            &#x2F;&#x2F; there may not be a view if this is running on the client
            if (mojitView) {

                data = data || {}; &#x2F;&#x2F; default null data to empty view template

                if (!contentType) {
                    meta.http.headers[&#x27;content-type&#x27;] = [&#x27;text&#x2F;html; &#x27; + CHARSET];
                }

                &#x2F;&#x2F; Merge instance.data + data, not need to do recursive merge.
                &#x2F;&#x2F; The properties from later objects will overwrite those in earlier objects.
                data = Y.merge(
                    instanceData || {},
                    data
                );

                &#x2F;&#x2F; some provisions for the view
                data.mojit_guid = instance.instanceId;
                data.mojit_view_id = meta.view.id;
                data.mojit_assets = instance.assetsRoot;

                &#x2F;&#x2F; page.data will be accessible in views thru &#x60;page&#x60;
                &#x2F;&#x2F; but only if the mojit is not overruling it by setting it
                &#x2F;&#x2F; thru ac.data.set(&#x27;page&#x27;, {}) or by ac.done({ page: {} })
                &#x2F;&#x2F; TODO: optimize this or it is going to happen
                &#x2F;&#x2F;       for every mojit instance in the page with a binder
                if (!data.page &amp;&amp; page.data &amp;&amp; page.data.toJSON) {
                    data.page = page.data.toJSON();
                }

                &#x2F;&#x2F; Use engine to compile template view
                &#x2F;&#x2F; Y.log(&#x27;Rendering &quot;&#x27; + meta.view.name + &#x27;&quot; view for &quot;&#x27; +
                &#x2F;&#x2F;     (instance.id || &#x27;@&#x27; + instance.type) + &#x27;&quot;&#x27;, &#x27;info&#x27;, NAME);

                &#x2F;&#x2F; TODO: we might want to use a view renderer factory
                &#x2F;&#x2F; that can provide caching capabilities for better performance
                &#x2F;&#x2F; instead of creating objects over and over again per mojit instance
                renderer = new Y.mojito.ViewRenderer(mojitView.engine, page.staticAppConfig.viewEngine);
                renderer.render(data, instance, mojitView, adapter, meta, more);

            } else {

                if (Y.Lang.isObject(data)) {
                    throw new Error(&quot;Missing view template: &#x27;&quot; + meta.view.name +
                        &quot;&#x27;&quot;);
                }
                adapter[callbackFunc](data, meta);
            }

            &#x2F;&#x2F; HookSystem::StartBlock
            Y.mojito.hooks.hook(&#x27;actionContextDone&#x27;, adapter.hook, &#x27;end2&#x27;, this);
            &#x2F;&#x2F; HookSystem::EndBlock
        },

        &#x2F;**
        * Programatically report an error to Mojito, which will handle it
        * gracefully.
        * @method error
        * @param {Error} err A normal JavaScript Error object is expected, but you
        *     may add a &quot;code&quot; property to the error if you want the framework to
        *     report a certain HTTP status code for the error. For example, if the
        *     status code is 404, Mojito will generate a 404 page. Additionally you
        *     might provide a reasonPhrase property, to override the default human
        *     readable description for this status code with one specific to your
        *     application. For example for the status code 404 you could provide
        *     &quot;This does not exist in my app&quot;.
        *&#x2F;
        error: function(err) {
            &#x2F;&#x2F; If we have an active timer clear it immediately.
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }

            this._adapter.error(err);
        }
    };

    Y.namespace(&#x27;mojito&#x27;).ActionContext = ActionContext;

}, &#x27;0.1.0&#x27;, {requires: [
    &#x27;mojito&#x27;,
    &#x27;json-stringify&#x27;,
    &#x27;event-custom-base&#x27;,
    &#x27;mojito-view-renderer&#x27;,
    &#x27;mojito-util&#x27;,
    &#x27;mojito-hooks&#x27;
]});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>

<!-- SpaceID=0 robot -->

<!-- VER-3.0.246810 -->
<!-- p1.ydn.bf1.yahoo.com uncompressed/chunked Fri Oct  4 11:13:12 PDT 2013 -->
