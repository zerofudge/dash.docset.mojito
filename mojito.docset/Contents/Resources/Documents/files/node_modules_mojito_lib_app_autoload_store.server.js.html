<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>node_modules&#x2F;mojito&#x2F;lib&#x2F;app&#x2F;autoload&#x2F;store.server.js - Mojito API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;developer.yahoo.com&#x2F;cocktails&#x2F;mojito&#x2F;api&#x2F;assets&#x2F;img&#x2F;mojito-logo-white-bkg.png" title="Mojito API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.7.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ActionContext.html">ActionContext</a></li>
            
                <li><a href="..&#x2F;classes/Analytics.common.html">Analytics.common</a></li>
            
                <li><a href="..&#x2F;classes/Assets.common.html">Assets.common</a></li>
            
                <li><a href="..&#x2F;classes/Composite.common.html">Composite.common</a></li>
            
                <li><a href="..&#x2F;classes/Config.common.html">Config.common</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.client.html">Cookie.client</a></li>
            
                <li><a href="..&#x2F;classes/Cookie.server.html">Cookie.server</a></li>
            
                <li><a href="..&#x2F;classes/Data.common.data.html">Data.common.data</a></li>
            
                <li><a href="..&#x2F;classes/Data.common.pageData.html">Data.common.pageData</a></li>
            
                <li><a href="..&#x2F;classes/Deploy.server.html">Deploy.server</a></li>
            
                <li><a href="..&#x2F;classes/Helpers.common.html">Helpers.common</a></li>
            
                <li><a href="..&#x2F;classes/Http.server.html">Http.server</a></li>
            
                <li><a href="..&#x2F;classes/Intl.common.html">Intl.common</a></li>
            
                <li><a href="..&#x2F;classes/Meta.common.html">Meta.common</a></li>
            
                <li><a href="..&#x2F;classes/Model.Vanilla.html">Model.Vanilla</a></li>
            
                <li><a href="..&#x2F;classes/Models.common.html">Models.common</a></li>
            
                <li><a href="..&#x2F;classes/MojitoDispatcher.html">MojitoDispatcher</a></li>
            
                <li><a href="..&#x2F;classes/MojitoPerf.html">MojitoPerf</a></li>
            
                <li><a href="..&#x2F;classes/MojitoRouter.html">MojitoRouter</a></li>
            
                <li><a href="..&#x2F;classes/MojitProxy.html">MojitProxy</a></li>
            
                <li><a href="..&#x2F;classes/OutputBuffer.html">OutputBuffer</a></li>
            
                <li><a href="..&#x2F;classes/OutputHandler.html">OutputHandler</a></li>
            
                <li><a href="..&#x2F;classes/Params.common.html">Params.common</a></li>
            
                <li><a href="..&#x2F;classes/Partial.common.html">Partial.common</a></li>
            
                <li><a href="..&#x2F;classes/ResourceStore.server.html">ResourceStore.server</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonConfig.html">RSAddonConfig</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonDispatchHelper.html">RSAddonDispatchHelper</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonMime.html">RSAddonMime</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonSelector.html">RSAddonSelector</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonUrl.html">RSAddonUrl</a></li>
            
                <li><a href="..&#x2F;classes/RSAddonYUI.html">RSAddonYUI</a></li>
            
                <li><a href="..&#x2F;classes/Url.common.html">Url.common</a></li>
            
                <li><a href="..&#x2F;classes/Y.mojito.Client.html">Y.mojito.Client</a></li>
            
                <li><a href="..&#x2F;classes/Y.mojito.lib.REST.html">Y.mojito.lib.REST</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ActionContext.html">ActionContext</a></li>
            
                <li><a href="..&#x2F;modules/ActionContextAddon.html">ActionContextAddon</a></li>
            
                <li><a href="..&#x2F;modules/app.html">app</a></li>
            
                <li><a href="..&#x2F;modules/CommonLibs.html">CommonLibs</a></li>
            
                <li><a href="..&#x2F;modules/Data.common.html">Data.common</a></li>
            
                <li><a href="..&#x2F;modules/model-vanilla.html">model-vanilla</a></li>
            
                <li><a href="..&#x2F;modules/mojito-perf.html">mojito-perf</a></li>
            
                <li><a href="..&#x2F;modules/MojitoClient.html">MojitoClient</a></li>
            
                <li><a href="..&#x2F;modules/MojitoHooks.html">MojitoHooks</a></li>
            
                <li><a href="..&#x2F;modules/OutputBuffer.html">OutputBuffer</a></li>
            
                <li><a href="..&#x2F;modules/ResourceStore.html">ResourceStore</a></li>
            
                <li><a href="..&#x2F;modules/ResourceStoreAddon.html">ResourceStoreAddon</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: node_modules&#x2F;mojito&#x2F;lib&#x2F;app&#x2F;autoload&#x2F;store.server.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
 * Copyright (c) 2011-2013, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 *&#x2F;


&#x2F;*jslint
    anon:true, sloppy:true, regexp: true, continue: true, nomen:true, node:true, stupid:true, plusplus: true
*&#x2F;
&#x2F;*global YUI*&#x2F;

&#x2F;**
 * The ResourceStore manages information about the &quot;resources&quot; in a Mojito
 * application.  These resources are things that have representation on the
 * filesystem.
 *
 * You generally don&#x27;t need to worry about this class (and its addons) unless
 * you are extending Mojito.
 *
 * Each resource can have many different versions.  This is not talking about
 * revisions, which is how the resource changes over time.  It is instead
 * talking about how there can be a version of the resource just for iphones,
 * one just for android, a fallback, etc.
 *
 * The metadata kept about each resource is normalized to the follow keys:
 * &lt;dl&gt;
 *      &lt;dt&gt;&lt;code&gt;source&lt;&#x2F;code&gt; (object)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;where the source came from.  (not shipped to the client.)
 *          &lt;dl&gt;
 *              &lt;dt&gt;&lt;code&gt;fs&lt;&#x2F;code&gt; (object)&lt;&#x2F;dt&gt;
 *              &lt;dd&gt;filesystem details&lt;&#x2F;dd&gt;
 *              &lt;dt&gt;&lt;code&gt;pkg&lt;&#x2F;code&gt; (object)&lt;&#x2F;dt&gt;
 *              &lt;dd&gt;packaging details&lt;&#x2F;dd&gt;
 *          &lt;&#x2F;dl&gt;
 *      &lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;mojit&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;which mojit this applies to, if any. (&quot;shared&quot; means the resource is available to all mojits.)&lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;type&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;resource type&lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;subtype&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;not all types of subtypes&lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;name&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;common to all versions of the resource&lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;id&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;unique ID.  common to all versions of the resource. (typically &lt;code&gt;{type}-{subtype}-{name}&lt;&#x2F;code&gt;.)&lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;yui&lt;&#x2F;code&gt; (object)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;for resources that are YUI modules&lt;&#x2F;dd&gt;
 *  &lt;&#x2F;dl&gt;
 *
 *  The following are only used in the metadata for each resource &lt;em&gt;version&lt;&#x2F;em&gt;
 *  (The metadata for resolved resources won&#x27;t have these, since they&#x27;re intrinsically
 *  part of the resolved resource.)
 *  &lt;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;affinity&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;runtime affinity.  either &lt;code&gt;server&lt;&#x2F;code&gt;, &lt;code&gt;client&lt;&#x2F;code&gt;, or &lt;code&gt;common&lt;&#x2F;code&gt;&lt;&#x2F;dd&gt;
 *      &lt;dt&gt;&lt;code&gt;selector&lt;&#x2F;code&gt; (string)&lt;&#x2F;dt&gt;
 *      &lt;dd&gt;version selector&lt;&#x2F;dd&gt;
 * &lt;&#x2F;dl&gt;
 *
 *
 * @module ResourceStore
 *&#x2F;
YUI.add(&#x27;mojito-resource-store&#x27;, function(Y, NAME) {

    &#x27;use strict&#x27;;

    var libs = {},

        resourceSortByDepthTest = function (a, b) {
            return a.source.pkg.depth - b.source.pkg.depth;
        },

        isNotAlphaNum = &#x2F;[^a-zA-Z0-9]&#x2F;,

        mojitoVersion = &#x27;0.666.666&#x27;,    &#x2F;&#x2F; special case for weird packaging situations

        CONVENTION_SUBDIR_TYPES = {
            &#x2F;&#x2F; subdir: resource type
            &#x27;actions&#x27;:  &#x27;action&#x27;,
            &#x27;binders&#x27;:  &#x27;binder&#x27;,
            &#x27;commands&#x27;: &#x27;command&#x27;,
            &#x27;middleware&#x27;: &#x27;middleware&#x27;,
            &#x27;models&#x27;:   &#x27;model&#x27;,
            &#x27;specs&#x27;:    &#x27;spec&#x27;,
            &#x27;views&#x27;:    &#x27;view&#x27;
        },
        CONVENTION_SUBDIR_TYPE_IS_JS = {
            &#x27;action&#x27;: true,
            &#x27;binder&#x27;: true,
            &#x27;model&#x27;: true
        },
        &#x2F;&#x2F; which addon subtypes are app-level
        ADDON_SUBTYPES_APPLEVEL = {
            &#x27;rs&#x27;: true
        },
        DEFAULT_AFFINITIES = {
            &#x27;action&#x27;: &#x27;server&#x27;,
            &#x27;addon&#x27;: &#x27;server&#x27;,
            &#x27;archetype&#x27;: &#x27;server&#x27;,
            &#x27;asset&#x27;: &#x27;common&#x27;,
            &#x27;binder&#x27;: &#x27;client&#x27;,
            &#x27;command&#x27;: &#x27;server&#x27;,
            &#x27;controller&#x27;: &#x27;server&#x27;,
            &#x27;middleware&#x27;: &#x27;server&#x27;,
            &#x27;model&#x27;: &#x27;server&#x27;,
            &#x27;spec&#x27;: &#x27;common&#x27;,
            &#x27;view&#x27;: &#x27;common&#x27;
        },
        PATH_SEP = require(&#x27;path&#x27;).sep;

    libs.fs = require(&#x27;fs&#x27;);
    libs.glob = require(&#x27;glob&#x27;);
    libs.path = require(&#x27;path&#x27;);
    libs.semver = require(&#x27;semver&#x27;);
    libs.walker = require(&#x27;.&#x2F;package-walker.server&#x27;);
    libs.util = require(&#x27;..&#x2F;..&#x2F;util.js&#x27;);

    &#x2F;&#x2F; The Affinity object is to manage the use of the affinity string in
    &#x2F;&#x2F; filenames.  Some files have affinities that have multiple parts
    &#x2F;&#x2F; (e.g. &quot;server-tests&quot;).
    function Affinity(affinity) {
        var parts;
        if (affinity.indexOf(&#x27;-&#x27;) === -1) {
            this.affinity = affinity;
        } else {
            parts = affinity.split(&#x27;-&#x27;);
            this.affinity = parts[0];
            this.type = parts[1];
        }
    }
    Affinity.prototype = {
        toString: function() {
            return this.affinity;
        }
    };



    &#x2F;**
     * @class ResourceStore.server
     * @constructor
     * @requires addon-rs-config, addon-rs-selector
     * @param {object} config configuration for the store
     *      @param {string} config.root directory to manage (usually the application directory)
     *      @param {object} config.context static context
     *      @param {object} config.appConfig overrides for &#x60;application.json&#x60;
     *&#x2F;
    function ResourceStore(config) {
        ResourceStore.superclass.constructor.apply(this, arguments);
    }
    ResourceStore.NAME = &#x27;ResourceStore&#x27;;
    ResourceStore.ATTRS = {};


    Y.extend(ResourceStore, Y.Base, {

        &#x2F;**
         * This methods is part of Y.Base.  See documentation for that for details.
         * @method initializer
         * @param {object} cfg Configuration object as per Y.Base
         * @return {nothing}
         *&#x2F;
        initializer: function(cfg) {
            var i;

            this._libs = {};
            for (i in libs) {
                if (libs.hasOwnProperty(i)) {
                    this._libs[i] = libs[i];
                }
            }

            this._config = cfg || {};
            this._config.context = this._config.context || {};
            this._config.appConfig = this._config.appConfig || {};
            this._config.dir = this._config.dir || process.cwd();
            this._config.root = this._config.root ||
                this._config.dir;
            this._config.mojitoRoot = this._config.mojitoRoot ||
                this._libs.path.join(__dirname, &#x27;..&#x2F;..&#x27;);

            this._jsonCache = {};   &#x2F;&#x2F; fullPath: contents as JSON object
            this._ycbCache = {};    &#x2F;&#x2F; fullPath: context: YCB config object
            this._routesCache = {}; &#x2F;&#x2F; serialized context: route
            this._appConfigCache = {}; &#x2F;&#x2F;cache for the app config
            this._validateContextCache = {};    &#x2F;&#x2F; ctx: error string or &quot;VALID&quot;
            this._getMojitTypeDetailsCache = {};    &#x2F;&#x2F; env+posl+lang+mojitType: value
            this._expandSpecCache = {}; &#x2F;&#x2F; env+ctx+spec: value

            this._packagesVisited = {}; &#x2F;&#x2F; package@version: path
            this._appRVs    = [];   &#x2F;&#x2F; array of resource versions
            this._mojitRVs  = {};   &#x2F;&#x2F; mojitType: array of resource versions
            this._appPkg = null;    &#x2F;&#x2F; metadata about the applicaions&#x27;s NPM package
            this._specPaths = {};   &#x2F;&#x2F; spec name: full path

            this._mojitDetails = {}; &#x2F;&#x2F; mojitType: selector: affinity: non-stringified details
            this._mojitDetailsCache = {}; &#x2F;&#x2F; mojitType+poslString+env: resolved resources

            &#x2F;**
             * All selectors that are actually in the app.
             * Key is selector, value is just boolean &#x60;true&#x60;.
             * This won&#x27;t be populated until &#x60;preloadResourceVersions()&#x60; is done.
             * @property selectors
             * @type Object
             *&#x2F;
            this.selectors = {};

            &#x2F;&#x2F; Y.Plugin AOP doesn&#x27;t allow afterHostMethod() callbacks to
            &#x2F;&#x2F; modify the results, so we fire an event instead.
            this.publish(&#x27;resolveMojitDetails&#x27;, {emitFacade: true, preventable: false});
            this.publish(&#x27;loadConfigs&#x27;, {emitFacade: true, preventable: false});

            &#x2F;&#x2F; We&#x27;ll start with just our &quot;config&quot; addon. Note that since we&#x27;re
            &#x2F;&#x2F; forcing the load we have to also include mojito-util.
            this._yuiUseSync({
                &#x27;addon-rs-config&#x27;: {
                    fullpath: this._libs.path.join(
                        this._config.mojitoRoot,
                        &#x27;app&#x2F;addons&#x2F;rs&#x2F;config.js&#x27;
                    )
                }
            });
            this.plug(Y.mojito.addons.rs.config, { appRoot: this._config.root, mojitoRoot: this._config.mojitoRoot });

            this.loadConfigs();

            Y.log(&#x27;Store initialized&#x27;, &#x27;info&#x27;, NAME);
        },

        destructor: function() {},


        &#x2F;&#x2F;====================================================================
        &#x2F;&#x2F; PUBLIC METHODS

        &#x2F;**
         * Loads the dimensions and configurations found in the app
         * @method loadConfigs
         *&#x2F;
        loadConfigs: function () {
            this._validDims = this._parseValidDims(this.config.getDimensions());
            this.validateContext(this._config.context);
            this._fwConfig = this.config.readConfigSimple(this._libs.path.join(this._config.mojitoRoot, &#x27;config.json&#x27;));
            this._appConfigYCB = this.config.getAppConfigYCB();
            this._appConfigStatic = this.getAppConfig({});

            this.lazyResolve = this._appConfigStatic.resourceStore &amp;&amp; this._appConfigStatic.resourceStore.lazyResolve;

            this.fire(&#x27;loadConfigs&#x27;);
        },

        &#x2F;**
         * Validates the context, and throws an exception if it isn&#x27;t.
         * @method validateContext
         * @param {object} ctx the context
         * @return {nothing} if this method returns at all then the context is valid
         *&#x2F;
        validateContext: function(ctx) {
            var cacheKey = JSON.stringify(ctx),
                cacheValue,
                k,
                parts,
                p,
                test,
                found;

            cacheValue = this._validateContextCache[cacheKey];
            if (cacheValue) {
                if (cacheValue === &#x27;VALID&#x27;) {
                    return;
                }
                throw new Error(cacheValue);
            }

            for (k in ctx) {
                if (ctx.hasOwnProperty(k)) {
                    if (!ctx[k]) {
                        continue;
                    }
                    if (&#x27;langs&#x27; === k) {
                        &#x2F;&#x2F; pseudo-context variable created by our middleware
                        continue;
                    }
                    if (!this._validDims[k]) {
                        this._validateContextCache[cacheKey] = &#x27;INVALID dimension key &quot;&#x27; + k + &#x27;&quot;&#x27;;
                        throw new Error(this._validateContextCache[cacheKey]);
                    }
                    &#x2F;&#x2F; we need to support language fallbacks
                    if (&#x27;lang&#x27; === k) {
                        found = false;
                        parts = ctx[k].split(&#x27;-&#x27;);
                        for (p = parts.length; p &gt; 0; p -= 1) {
                            test = parts.slice(0, p).join(&#x27;-&#x27;);
                            if (this._validDims[k][test]) {
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            this._validateContextCache[cacheKey] = &#x27;INVALID dimension value &quot;&#x27; + ctx[k] + &#x27;&quot; for key &quot;&#x27; + k + &#x27;&quot;&#x27;;
                            throw new Error(this._validateContextCache[cacheKey]);
                        }
                        continue;
                    }
                    if (!this._validDims[k][ctx[k]]) {
                        this._validateContextCache[cacheKey] = &#x27;INVALID dimension value &quot;&#x27; + ctx[k] + &#x27;&quot; for key &quot;&#x27; + k + &#x27;&quot;&#x27;;
                        throw new Error(this._validateContextCache[cacheKey]);
                    }
                }
            }
            this._validateContextCache[cacheKey] = &#x27;VALID&#x27;;
            return true;
        },


        &#x2F;**
         * Returns the context provided blended with the static
         * (non-runtime-sensitive) context.
         * @method blendStaticContext
         * @param {object} ctx The context to blend.
         * @return {object} the context
         *&#x2F;
        blendStaticContext: function(ctx) {
            return Y.mojito.util.blend(this._config.context, ctx);
        },


        &#x2F;**
         * Returns the static (non-runtime-sensitive) context
         * @method getStaticContext
         * @return {object} the context
         *&#x2F;
        getStaticContext: function() {
            return Y.mojito.util.copy(this._config.context);
        },


        &#x2F;**
         * Returns the static (non-runtime-sensitive) version of the application.json.
         * @method getStaticAppConfig
         * @return {object} the configuration from applications.json
         *&#x2F;
        getStaticAppConfig: function() {
            return Y.mojito.util.copy(this._appConfigStatic);
        },


        &#x2F;**
         * Returns Mojito&#x27;s built-in configuration.
         * @method getFrameworkConfig
         * @return {object} the configuration for mojito
         *&#x2F;
        getFrameworkConfig: function() {
            return Y.mojito.util.copy(this._fwConfig);
        },

        &#x2F;**
         * Returns a contextualized application configuration.
         * @method getAppConfig
         * @param {object} ctx the context
         * @return {object} the application configuration contextualized by the &quot;ctx&quot; argument.
         *&#x2F;
        getAppConfig: function(ctx) {
            var appConfig,
                key,
                ycb;

            ctx = this.blendStaticContext(ctx);
            key = JSON.stringify(ctx || {});

            if (this._appConfigCache[key]) {
                return JSON.parse(this._appConfigCache[key]);
            }

            ycb = this._appConfigYCB.read(ctx);

            appConfig = Y.mojito.util.blend(this._fwConfig.appConfigBase, this._config.appConfig);
            appConfig = Y.mojito.util.blend(appConfig, ycb);

            this._appConfigCache[key] = JSON.stringify(appConfig);

            return appConfig;
        },

        &#x2F;**
         * Does initial preload of many parts of the application and framework.
         * The full preload is done by preload().
         *
         * @method preloadInitial
         * @return {nothing}
         *&#x2F;
        preloadInitial: function() {
            if (!this._initialPreloaded) {

                this.preloadResourceVersions();
                &#x2F;&#x2F; binding the preload to avoid calling it twice.
                this._initialPreloaded = true;

                Y.log(&#x27;Store initial preloaded&#x27;, &#x27;info&#x27;, NAME);
            }
        },


        &#x2F;**
         * Preloads everything in the app, and as well pertinent parts of
         * the framework.
         *
         * @method preload
         * @return {nothing}
         *&#x2F;
        preload: function() {
            &#x2F;&#x2F; We need to do an initial sweep to find the resource store addons.
            this.preloadInitial();

            &#x2F;&#x2F; And then use them.
            if (this.loadAddons()) {
                &#x2F;&#x2F; If we loaded some addons, do another sweep so that the loaded addons can be used.
                this.preloadResourceVersions();

                &#x2F;&#x2F; reload the configs so that the addons get a chance to mess with them
                this.loadConfigs();
            }

            this.makeResourceVersions();
            this.resolveResourceVersions();

            Y.log(&#x27;Store fully preloaded&#x27;, &#x27;info&#x27;, NAME);
        },


        &#x2F;**
         * Optimizes this store for the specific runtime, or for &quot;production&quot; if none given in static context.
         * @method optimizeForEnvironment
         * @return {nothing}
         *&#x2F;
        optimizeForEnvironment: function() {
            this._packagesVisited = {};
            if (!this.lazyResolve) {
                this._appRVs = [];
                this._mojitRVs = {};
            }
        },

        &#x2F;**
         * Returns a list of resource versions that match the filter.
         * (To get the list of resource versions from all mojits, you&#x27;ll need
         * to call &#x60;listAllMojits()&#x60; and iterate over that list, calling this
         * method with &#x60;mojit:&#x60; in the filter.)
         *
         * @method getResourceVersions
         * @param {object} filter limit returned resource versions to only those whose keys&#x2F;values match the filter
         * @return {array of objects} list of matching resource versions
         *&#x2F;
        getResourceVersions: function(filter) {
            var source = [],
                out = [],
                r,
                res,
                k,
                use;

            source = filter.mojit ? this._mojitRVs[filter.mojit] : this._appRVs;
            if (!source) {
                return [];
            }
            for (r = 0; r &lt; source.length; r += 1) {
                res = source[r];
                use = true;
                for (k in filter) {
                    if (filter.hasOwnProperty(k)) {
                        if (res[k] !== filter[k]) {
                            use = false;
                            break;
                        }
                    }
                }
                if (use) {
                    out.push(res);
                }
            }
            return out;
        },


        &#x2F;**
         * Returns a list of all mojits in the app, except for the &quot;shared&quot; mojit.
         * @method listAllMojits
         * @return {array} list of mojits
         *&#x2F;
        listAllMojits: function() {
            var mojitType,
                list = [];
            for (mojitType in this._mojitRVs) {
                if (this._mojitRVs.hasOwnProperty(mojitType)) {
                    if (&#x27;shared&#x27; !== mojitType) {
                        list.push(mojitType);
                    }
                }
            }
            return list;
        },


        &#x2F;**
         * This just calls &#x60;expandInstanceForEnv()&#x60; with &#x60;env&#x60; set to &#x60;server&#x60;.
         *
         * @async
         * @method expandInstance
         * @param {map} instance partial instance to expand
         * @param {object} ctx the context
         * @param {function(err,instance)} cb callback used to return the results (or error)
         *&#x2F;
        expandInstance: function(instance, ctx, cb) {
            this.expandInstanceForEnv(&#x27;server&#x27;, instance, ctx, cb);
            return;
        },


        &#x2F;**
         * Expands the instance into all details necessary to dispatch the mojit.
         *
         * @async
         * @method expandInstanceForEnv
         * @param {string} env the runtime environment (either &#x60;client&#x60; or &#x60;server&#x60;)
         * @param {object} instance
         * @param {object} ctx the context
         * @param {function(err,instance)} cb callback used to return the results (or error)
         *&#x2F;
        expandInstanceForEnv: function(env, instance, ctx, cb) {
            var spec,
                typeDetails,
                newInst,
                key;

            &#x2F;&#x2F; TODO:  should this be done here, or somewhere else?
            ctx.runtime = env;

            if (!instance.instanceId) {
                instance.instanceId = Y.guid();
                &#x2F;&#x2F;DEBUGGING:  instance.instanceId += &#x27;-instance-server-&#x27; + [instance.base||&#x27;&#x27;, instance.type||&#x27;&#x27;].join(&#x27;-&#x27;);
            }

            &#x2F;&#x2F; spec
            try {
                spec = this._expandSpec(env, ctx, instance);
            } catch (err) {
                return cb(err);
            }
            if (!spec.config) {
                spec.config = {};
            }

            &#x2F;&#x2F; type details
            try {
                typeDetails = this.getMojitTypeDetails(env, ctx, spec.type);
            } catch (err2) {
                return cb(err2);
            }

            &#x2F;&#x2F; This approach gives a noticeable performance improvement when
            &#x2F;&#x2F; typeDetails.config is empty.
            newInst = Y.mojito.util.copy(typeDetails);
            for (key in spec) {
                if (spec.hasOwnProperty(key)) {
                    if ((&#x27;object&#x27; === typeof typeDetails[key]) &amp;&amp; Object.keys(typeDetails[key]).length &gt; 0) {
                        if ((&#x27;object&#x27; === typeof spec[key]) &amp;&amp; Object.keys(spec[key]).length &gt; 0) {
                            newInst[key] = Y.mojito.util.blend(typeDetails[key], spec[key] || {});
                        }
                    } else {
                        newInst[key] = spec[key];
                    }
                }
            }
            &#x2F;&#x2F; spec doesn&#x27;t (appreciably) contain base
            newInst.base = instance.base;

            cb(null, newInst);
        },


        &#x2F;**
         * Returns details about a mojit type.
         *
         * As the last step of execution, this fires the &#x60;getMojitTypeDetails&#x60;
         * event so that Resource Store addons can augment the returned structure.
         *
         * NOTE! This returns an object which is shared with similar calls to
         * this method.  If you intend to modify the object please make a deep
         * copy first and use that instead.
         *
         * @method getMojitTypeDetails
         * @param {string} env the runtime environment (either &#x60;client&#x60; or &#x60;server&#x60;)
         * @param {object} ctx the context
         * @param {string} mojitType mojit type
         * @param {object} dest DEPRECATED: object in which to place the results
         * @return {object} details about the mojit type
         *&#x2F;
        &#x2F;**
         * Fired at the end of the &#x60;getMojitTypeDetails()&#x60; method to allow
         * modification of the results.
         * @event getMojitTypeDetails
         * @param {object} args input arguments
         *      @param {string} args.env the runtime environment (either &#x60;client&#x60; or &#x60;server&#x60;)
         *      @param {object} args.ctx runtime context
         *      @param {array} args.posl priority-ordered seletor list
         *      @param {string} args.mojitType name of mojit
         * @param {object} mojit the mojit type details
         *&#x2F;
        getMojitTypeDetails: function(env, ctx, mojitType, dest, DANGERDANGERreturnRawCacheValue) {
            &#x2F;&#x2F;Y.log(&#x27;getMojitTypeDetails(&#x27;+env+&#x27;, &#x27;+JSON.stringify(ctx)+&#x27;, &#x27;+mojitType+&#x27;)&#x27;, &#x27;debug&#x27;, NAME);
            var posl = this.selector.getPOSLFromContext(ctx),
                poslKey = JSON.stringify(posl),
                &#x2F;&#x2F; We need to include the lang, since it&#x27;s a part of the context
                &#x2F;&#x2F; that greatly affects each mojit, yet is not necessarily
                &#x2F;&#x2F; captured in the POSL.
                cacheKey = JSON.stringify([env, posl, ctx.lang, mojitType]),
                cacheValue = this._getMojitTypeDetailsCache[cacheKey],
                details;

            if (&#x27;shared&#x27; === mojitType) {
                throw new Error(&#x27;Mojit name &quot;shared&quot; is special and isn\&#x27;t a real mojit.&#x27;);
            }

            if (!cacheValue) {

                details = this.resolveVersion(mojitType, env, posl);

                details.defaults = this.config.readConfigYCB(this._libs.path.join(details.fullPath, &#x27;defaults.json&#x27;), ctx);
                details.definition = this.config.readConfigYCB(this._libs.path.join(details.fullPath, &#x27;definition.json&#x27;), ctx);
                if (details.defaults &amp;&amp; details.defaults.config) {
                    details.config = Y.mojito.util.blend(details.defaults.config, details.config);
                }
                &#x2F;&#x2F; we shouldn&#x27;t expose this
                if (&#x27;client&#x27; === env) {
                    details.fullPath = undefined;
                }

                cacheValue = details;
                this._getMojitTypeDetailsCache[cacheKey] = cacheValue;
            }

            if (dest) {
                Y.log(&#x27;The &quot;dest&quot; parameter to store.getMojitTypeDetails() is deprecated.&#x27;, &#x27;warn&#x27;, NAME);
                Y.mojito.util.mergeRecursive(dest, cacheValue);
            }
            return cacheValue;
        },


        &#x2F;**
         * Cooks down the list of resolved mojit resources into a single structure.
         * @method resolveMojitDetails
         * @param {string} env the runtime environment (either &#x60;client&#x60; or &#x60;server&#x60;)
         * @param {object} posl priority-ordered seletor list
         * @param {string} type name of mojit
         * @param {array} ress array of resources for the mojit
         * @param {object} mojitRes resource for the mojit itself
         * @return {object} details for the mojit
         *&#x2F;
        &#x2F;**
         * Fired at the end of the &#x60;resolveMojitDetails()&#x60; method to allow
         * modification of the results.
         * @event resolveMojitDetails
         * @param {object} args input arguments
         *      @param {string} args.env the runtime environment (either &#x60;client&#x60; or &#x60;server&#x60;)
         *      @param {array} args.posl priority-ordered seletor list
         *      @param {string} args.type name of mojit
         *      @param {array} args.ress array of resources for the mojit
         *      @param {object} args.mojitRes resource for the mojit itself
         * @param {object} details details for the mojit
         *&#x2F;
        resolveMojitDetails: function(env, posl, type, ress, mojitRes) {
            var poslKey = JSON.stringify(posl),
                r,
                res,
                clientDetails,
                details = {
                    fullPath: mojitRes.source.fs.fullPath,
                    &#x2F;&#x2F;defaults       can only be evaluated at runtime
                    &#x2F;&#x2F;definition     can only be evaluated at runtime
                    assets: {},
                    binders: {},
                    config: {},
                    langs: {},
                    models: {},
                    partials: {},
                    views: {}
                },
                template,
                specPath;

            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];

                if (res.type === &#x27;config&#x27;) {
                    &#x2F;&#x2F; these can only be determined using the runtime context
                    continue;
                }

                if (res.type === &#x27;asset&#x27;) {
                    if (env === &#x27;client&#x27;) {
                        details.assets[res.name + res.source.fs.ext] = res.url;
                    } else {
                        details.assets[res.name + res.source.fs.ext] = res.source.fs.fullPath;
                    }
                    continue;
                }

                if (res.type === &#x27;controller&#x27;) {
                    details.controller = res.yui.name;
                    continue;
                }

                if (res.type === &#x27;yui-lang&#x27;) {
                    details.langs[res.yui.lang] = true;
                    if (res.yui.isRootLang) {
                        details.defaultLang = res.yui.lang;
                    }
                    continue;
                }

                if (res.type === &#x27;model&#x27;) {
                    details.models[res.name] = res.yui.name;
                    continue;
                }

                if (res.type === &#x27;binder&#x27;) {
                    details.binders[res.name] = res.yui.name;
                    continue;
                }

                if (res.type === &#x27;view&#x27;) {
                    template = {
                        &#x27;content-path&#x27;: (env === &#x27;client&#x27; ?
                                this._libs.util.webpath(this._appConfigStatic.pathToRoot || &#x27;&#x27;, res.url) :
                                res.source.fs.fullPath),
                        &#x27;content&#x27;: res.content,
                        &#x27;engine&#x27;: res.view.engine
                    };
                    &#x2F;&#x2F; we want to separate partials from actual templates
                    &#x2F;&#x2F; in case the engine supports partials
                    if (res.name.indexOf(&#x27;partials&#x2F;&#x27;) === 0) {
                        &#x2F;&#x2F; removing the &quot;partials&#x2F;&quot; prefix
                        details.partials[this._libs.path.basename(res.name)] = template;
                    } else {
                        details.views[res.name] = template;
                        details.views[res.name].assets = res.view.assets;
                        details.views[res.name].engine = res.view.engine;
                    }
                    continue;
                }

                if (res.type === &#x27;spec&#x27;) {
                    &#x2F;&#x2F; During runtime we only need to know a little bit about the specs.
                    specPath = res.mojit;
                    if (res.name !== &#x27;default&#x27;) {
                        specPath += &#x27;:&#x27; + res.name;
                    }
                    this._specPaths[specPath] = res.source.fs.fullPath;
                    continue;
                }

                if (res.type === &#x27;addon&#x27;) {
                    &#x2F;&#x2F; No need to track either of these explicitly, since
                    &#x2F;&#x2F; AC addons is handled by calculating dependencies of the
                    &#x2F;&#x2F; controller, and view engines are handled by the view
                    &#x2F;&#x2F; filenames.
                    continue;
                }
            }

            &#x2F;&#x2F; Since the binders are not part of the server runtime, but are needed
            &#x2F;&#x2F; to define the binders map, we need to synthetically build this.
            if (env !== &#x27;client&#x27;) {
                clientDetails = this.resolveVersion(type, &#x27;client&#x27;, posl);
                details.binders = clientDetails.binders;
            }

            this.fire(&#x27;resolveMojitDetails&#x27;, {
                args: {
                    env: env,
                    posl: posl,
                    type: type,
                    ress: ress,
                    mojitRes: mojitRes
                },
                mojitDetails: details
            });

            return details;
        },


        &#x2F;**
         * Returns the routes configured in the application.
         * @method getRoutes
         * @param {object} ctx the context
         * @return {object} routes
         *&#x2F;
        getRoutes: function(ctx) {
            var appConfig,
                cachedValue,
                key = JSON.stringify(ctx || {}),
                routesFiles = [],
                p,
                path,
                out = {},
                routes;

            cachedValue = this._routesCache[key];
            if (cachedValue) {
                return JSON.parse(cachedValue);
            }

            appConfig = this.getAppConfig(ctx);
            if (appConfig) {
                routesFiles = appConfig.routesFiles;
            }

            for (p = 0; p &lt; routesFiles.length; p += 1) {
                path = routesFiles[p];
                &#x2F;&#x2F; relative paths are relative to the application
                path = this._libs.path.resolve(this._config.root, path);
                routes = this.config.readConfigYCB(path, ctx);
                Y.mix(out, routes, true);
            }

            if (!Object.keys(out).length) {
                Y.mix(out, this._fwConfig.defaultRoutes, true);
            }

            this._routesCache[key] = JSON.stringify(out);
            return out;
        },


        &#x2F;**
         * Sugar method that returns all &quot;url&quot; metadata of all resources.
         * @method getAllURLs
         * @return {object} for all resources with a &quot;url&quot; metadatum, the key is
         *      that URL and the value the filesystem path
         *&#x2F;
        getAllURLs: function() {
            var r,
                res,
                ress,
                m,
                mojit,
                mojits,
                urls = {};
            mojits = this.listAllMojits();
            mojits.push(&#x27;shared&#x27;);
            for (m = 0; m &lt; mojits.length; m += 1) {
                mojit = mojits[m];
                ress = this.getResourceVersions({mojit: mojit});
                for (r = 0; r &lt; ress.length; r += 1) {
                    res = ress[r];
                    if (res.url) {
                        urls[res.url] = res.source.fs.fullPath;
                    }
                }
            }
            return urls;
        },


        &#x2F;**
         * turns a resource into a datastructure for the static handler
         * @method makeStaticHandlerDetails
         * @param {object} res The resource.
         * @return {object} A concise version of the resource containing just the details necessary
         *      to serve the resource via the static handler.
         *&#x2F;
        makeStaticHandlerDetails: function(res) {
            var details = {
                type: res.type,
                subtype: res.subtype,
                name: res.name,
                path: res.source.fs.fullPath,
                url: res.url
            };
            if (res.mojit) {
                details.mojit = res.mojit;
            }
            if (res.mime) {
                details.mimetype = res.mime.type;
                details.charset = res.mime.charset;
            }
            return details;
        },


        &#x2F;**
         * Sugar method that returns a hash table with the urls and the
         * resource objects.
         * @method getAllURLDetails
         * @return {object} for all resources with a &quot;url&quot; metadatum, the key is
         *      that URL and the value is the results of the makeStaticHandlerDetails() call
         *&#x2F;
        getAllURLDetails: function() {
            var r,
                res,
                ress,
                m,
                mojit,
                mojits,
                urls = {};
            ress = this.getResourceVersions({});
            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];
                if (res.url &amp;&amp; res.source.fs.isFile) {
                    urls[res.url] = this.makeStaticHandlerDetails(res);
                }
            }
            mojits = this.listAllMojits();
            mojits.push(&#x27;shared&#x27;);
            for (m = 0; m &lt; mojits.length; m += 1) {
                mojit = mojits[m];
                ress = this.getResourceVersions({mojit: mojit});
                for (r = 0; r &lt; ress.length; r += 1) {
                    res = ress[r];
                    if (res.url &amp;&amp; res.source.fs.isFile) {
                        if (urls[res.url]) {
                            if (urls[res.url].path !== res.source.fs.fullPath) {
                                Y.log(&#x27;Url collision for &#x27; + res.url +
                                    &#x27;. Choosing:\n&#x27; + urls[res.url].path +
                                    &#x27; over\n&#x27; + res.source.fs.fullPath, &#x27;debug&#x27;, NAME);
                            }
                        } else {
                            urls[res.url] = this.makeStaticHandlerDetails(res);
                        }
                    }
                }
            }
            return urls;
        },


        &#x2F;**
         * Finds the file represented by the resource, and returns its contents and filesystem info.
         * @method getResourceContent
         * @param {object} details static handling details
         * @param {function} callback callback used to return the resource content (or error)
         * @param {Error|undefined} callback.err Error that occurred, if any.
         *      If an error is given that the other two arguments will be undefined.
         * @param {Buffer} callback.content the contents of the resource
         * @param {Stat||null} callback.stat Stat object with details about the file on the filesystem
         *          Can be null if the resource doesn&#x27;t have a direct representation on the filesystem.
         * @return {undefined} nothing is returned, the results are returned via the callback
         *&#x2F;
        getResourceContent: function(details, callback) {
            var store = this,
                filename;

            if (details &amp;&amp; details.path) {
                filename = details.path;

                &#x2F;&#x2F; FUTURE [Issue 89] stat cache?
                store._libs.fs.stat(filename, function(err, stat) {
                    if (err) {
                        Y.log(&#x27;failed to find: &#x27; + filename, &#x27;warn&#x27;, NAME);
                        &#x2F;&#x2F; TODO: [Issue 90] send next an error?
                        callback(err);
                        return;
                    }
                    &#x2F;&#x2F; reading the file directly using buffers
                    store._libs.fs.readFile(filename, function (err, content) {
                        if (err) {
                            Y.log(&#x27;NOT FOUND: &#x27; + filename, &#x27;warn&#x27;, NAME);
                            callback(err);
                            return;
                        }
                        store.processResourceContent(details, content, stat, callback);
                    });

                });

            } else {
                &#x2F;&#x2F; invalid res object
                callback(new Error(&#x27;Invalid resource store reference&#x27;));
            }
        },


        &#x2F;**
         * A method that transforms the content of a resource as it&#x27;s being read
         * from the filesystem.  This method does nothing, but provides a hook
         * point for resource store addons to transform resource contents.
         * @method processResourceContent
         * @param {object} details static handling details
         * @param {Buffer} content the contents of the resource
         * @param {Stat||null} callback.stat Stat object with details about the file on the filesystem
         *          Can be null if the resource doesn&#x27;t have a direct representation on the filesystem.
         * @param {function} callback callback passed to &#x60;getResourceContent()&#x60;.
         * @return {nothing} results returned via the callback
         *&#x2F;
        processResourceContent: function(details, content, stat, callback) {
            callback(undefined, content, stat);
        },


        &#x2F;**
         * Recursively merge one object onto another.
         * [original implementation](http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;171251&#x2F;how-can-i-merge-properties-of-two-javascript-objects-dynamically&#x2F;383245#383245)
         *
         * @method mergeRecursive
         * @param {object} dest object to merge into
         * @param {object} src object to merge onto &quot;dest&quot;
         * @param {boolean} typeMatch controls whether a non-object in the src is
         *          allowed to clobber a non-object in the dest (if a different type)
         * @return {object} the modified &quot;dest&quot; object is also returned directly
         *&#x2F;
        mergeRecursive: function(dest, src, typeMatch) {
            var p;
            for (p in src) {
                if (src.hasOwnProperty(p)) {
                    &#x2F;&#x2F; Property in destination object set; update its value.
                    if (src[p] &amp;&amp; src[p].constructor === Object) {
                        if (!dest[p]) {
                            dest[p] = {};
                        }
                        dest[p] = this.mergeRecursive(dest[p], src[p]);
                    } else {
                        if (dest[p] &amp;&amp; typeMatch) {
                            if (typeof dest[p] === typeof src[p]) {
                                dest[p] = src[p];
                            }
                        } else {
                            dest[p] = src[p];
                        }
                    }
                }
            }
            return dest;
        },


        &#x2F;**
         * Returns information about the application&#x27;s NPM package.  This is
         * primarily useful when creating resources in &#x60;makeResourceVersions()&#x60;.
         * @method getAppPkgMeta
         * @return {object} metadata about the application&#x27;s NPM package
         *&#x2F;
        getAppPkgMeta:  function() {
            return this._appPkg;
        },


        &#x2F;**
         * Creates the filesystem metadata for a resource.  This is primarily
         * useful when creating resources in &#x60;makeResourceVersions()&#x60;.
         * @method makeResourceFSMeta
         * @param {string} dir directory path
         * @param {string} dirType type represented by the &quot;dir&quot; argument.  values are &quot;app&quot;, &quot;bundle&quot;, &quot;pkg&quot;, or &quot;mojit&quot;
         * @param {string} subdir directory path within &quot;dir&quot;.
         * @param {string} file name of the file or directory
         * @param {boolean} isFile indicates whether the path is a file (true) or diretory (false)
         * @return {object} filesystem metadata
         *&#x2F;
        makeResourceFSMeta: function(dir, dirType, subdir, file, isFile) {
            var fs = {
                fullPath: this._libs.path.join(dir, subdir, file),
                rootDir: dir,
                rootType: dirType,
                subDir: subdir,
                subDirArray: subdir.split(PATH_SEP),
                isFile: isFile,
                ext: this._libs.path.extname(file)
            };
            fs.basename = this._libs.path.basename(file, fs.ext);
            return fs;
        },


        &#x2F;&#x2F;====================================================================
        &#x2F;&#x2F; CALLBACK METHODS
        &#x2F;&#x2F; These are called at various points in the algorithm of public
        &#x2F;&#x2F; methods.  They are public so that they can be hooked into via AOP.


        &#x2F;**
         * Augments this resource store with addons that we know about.
         * To find the addons, call &#x60;preloadResourceVersions()&#x60; first.
         *
         * You most often don&#x27;t want to call this directly, but instead to hook
         * into it using the AOP mechanism of &#x60;Y.Plugin.Base&#x60;:
         *
         *     this.afterHostMethod(&#x27;loadAddons&#x27;, this._myLoadAddons, this);
         *
         * @method loadAddons
         * @return {Number} the number of loaded addons
         *&#x2F;
        loadAddons: function() {
            var modules = {},
                ress,
                r,
                res;

            ress = this.getResourceVersions({type: &#x27;addon&#x27;, subtype: &#x27;rs&#x27;});
            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];
                if (&#x27;rs&#x27; === res.subtype) {
                    &#x2F;&#x2F; FUTURE:  ideally we shouldn&#x27;t proscribe the YUI module name of RS addons
                    &#x2F;&#x2F; (We can&#x2F;should introspect the file for the YUI module name.)
                    modules[&#x27;addon-rs-&#x27; + res.name] = {
                        fullpath: res.source.fs.fullPath
                    };
                }
            }
            this._yuiUseSync(modules);

            Y.Object.each(Y.mojito.addons.rs, function(fn, name) {
                &#x2F;&#x2F; skipping any rs addon that was already plugged during the init phase (e.g.: config)
                if (fn.NS &amp;&amp; !this[fn.NAME]) {
                    this.plug(fn, { appRoot: this._config.root, mojitoRoot: this._config.mojitoRoot });
                }
            }, this);
            return Object.keys(modules).length;
        },


        &#x2F;**
         * Preload metadata about all resource versions in the application
         * (and Mojito framework).
         *
         * You most often don&#x27;t want to call this directly, but instead to hook
         * into it using the AOP mechanism of &#x60;Y.Plugin.Base&#x60;:
         *
         *     this.afterHostMethod(&#x27;preloadResourceVersions&#x27;, this._myPreloadResourceVersions, this);
         *
         * @method preloadResourceVersions
         * @return {nothing}
         *&#x2F;
        preloadResourceVersions: function() {
            var me = this,
                walker,
                walkedMojito = false,
                dir,
                info;

            this.selectors = {};
            this._appRVs = [];
            this._mojitRVs = {};
            this._packagesVisited = {};

            walker = new this._libs.walker.BreadthFirst(this._config.root);
            walker.walk(function(err, info) {
                if (err) {
                    throw err;
                }
                if (&#x27;mojito&#x27; === info.pkg.name) {
                    walkedMojito = true;
                }
                me._preloadPackage(info);
            });

            &#x2F;&#x2F; user might not have installed mojito as a dependency of their
            &#x2F;&#x2F; application.  (they -should- have but might not have.)
            &#x2F;&#x2F; FUTURE:  instead walk -all- global packages?
            if (!walkedMojito) {
                dir = this._libs.path.join(this._config.mojitoRoot, &#x27;..&#x27;);
                info = {
                    depth: 999,
                    parents: [],
                    dir: dir
                };
                info.pkg = this.config.readConfigJSON(this._libs.path.join(dir, &#x27;package.json&#x27;));

                if (Object.keys(info.pkg).length) {
                    mojitoVersion = info.pkg.version;
                } else {
                    &#x2F;&#x2F; special case for weird packaging situations
                    info.dir = this._config.mojitoRoot;
                    info.pkg = {
                        name: &#x27;mojito&#x27;,
                        version: mojitoVersion,
                        yahoo: {
                            mojito: {
                                type: &#x27;bundle&#x27;,
                                location: &#x27;app&#x27;
                            }
                        }
                    };
                }

                this._preloadPackage(info);
            }
        },


        &#x2F;**
         * Called by the ResourceStore to decide if a file should be considered
         * a resource.  You most often don&#x27;t want to call this directly, but
         * instead to hook into it using the AOP mechanism of &#x60;Y.Plugin.Base&#x60;:
         *
         *     this.afterHostMethod(&#x27;findResourceVersionByConvention&#x27;, this._myFindResourceByConvention, this);
         *
         * Generally &#x60;findResourceVersionByConvention()&#x60; and &#x60;parseResourceVersion()&#x60; are meant to work together.
         * This method figures out the type (and subtype) of a file, and &#x60;parseResourceVersion()&#x60; turns
         * the file into an actual resource.
         *
         * @method findResourceVersionByConvention
         * @param {object} source the same as the &#x60;source&#x60; part of a resource
         * @param {string} mojitType the name of the mojit
         * @return {boolean|object} If the source is a directory, a boolean can be returned.
         *      True indicates that the directory contents should be scanned, while false
         *      indicates that the directory should be skipped.
         *      If the source does represent a resource, then an object with the following
         *      fields should be returned:
         *      type {string} type of the resource,
         *      subtype {string} optional subtype of the resource,
         *      skipSubdirParts {integer} number of path parts of &#x60;source.fs.subDir&#x60; to skip
         *&#x2F;
        findResourceVersionByConvention: function(source, mojitType) {
            var fs = source.fs,
                baseParts = fs.basename.split(&#x27;.&#x27;),
                type;

            if (!fs.isFile &amp;&amp; &#x27;.&#x27; === fs.subDir &amp;&amp; CONVENTION_SUBDIR_TYPES[fs.basename]) {
                return true;
            }
            type = CONVENTION_SUBDIR_TYPES[fs.subDirArray[0]];
            if (!fs.isFile &amp;&amp; type) {
                return true;
            }
            if (fs.isFile &amp;&amp; type &amp;&amp; fs.subDirArray.length &gt;= 1) {
                if (CONVENTION_SUBDIR_TYPE_IS_JS[type] &amp;&amp; &#x27;.js&#x27; !== fs.ext) {
                    return false;
                }

                if (&#x27;spec&#x27; === type &amp;&amp; (&#x27;.json&#x27; !== fs.ext &amp;&amp; &#x27;.yaml&#x27; !== fs.ext &amp;&amp; &#x27;.yml&#x27; !== fs.ext)) {
                    return false;
                }

                return {
                    type: type,
                    skipSubdirParts: 1
                };
            }

            &#x2F;&#x2F; special case:  addons
            if (!fs.isFile &amp;&amp; &#x27;.&#x27; === fs.subDir &amp;&amp; &#x27;addons&#x27; === fs.basename) {
                return true;
            }
            if (!fs.isFile &amp;&amp; fs.subDirArray.length &lt; 2 &amp;&amp; &#x27;addons&#x27; === fs.subDirArray[0]) {
                return true;
            }
            if (fs.isFile &amp;&amp; fs.subDirArray.length &gt;= 1 &amp;&amp; &#x27;addons&#x27; === fs.subDirArray[0]) {
                if (&#x27;.js&#x27; !== fs.ext) {
                    return false;
                }
                return {
                    type: &#x27;addon&#x27;,
                    subtype: fs.subDirArray[1],
                    skipSubdirParts: 2
                };
            }

            &#x2F;&#x2F; special case:  archetypes
            if (!fs.isFile &amp;&amp; &#x27;.&#x27; === fs.subDir &amp;&amp; &#x27;archetypes&#x27; === fs.basename) {
                return true;
            }
            if (!fs.isFile &amp;&amp; fs.subDirArray.length &lt; 2 &amp;&amp; &#x27;archetypes&#x27; === fs.subDirArray[0]) {
                return true;
            }
            if (!fs.isFile &amp;&amp; fs.subDirArray.length === 2 &amp;&amp; &#x27;archetypes&#x27; === fs.subDirArray[0]) {
                return {
                    type: &#x27;archetype&#x27;,
                    subtype: fs.subDirArray[1],
                    skipSubdirParts: 2
                };
            }

            &#x2F;&#x2F; special case:  assets
            if (!fs.isFile &amp;&amp; &#x27;.&#x27; === fs.subDir &amp;&amp; &#x27;assets&#x27; === fs.basename) {
                return true;
            }
            if (!fs.isFile &amp;&amp; &#x27;assets&#x27; === fs.subDirArray[0]) {
                return true;
            }
            if (fs.isFile &amp;&amp; &#x27;assets&#x27; === fs.subDirArray[0] &amp;&amp; fs.subDirArray.length &gt;= 1) {
                return {
                    type: &#x27;asset&#x27;,
                    subtype: fs.ext.substr(1),
                    skipSubdirParts: 1
                };
            }

            &#x2F;&#x2F; special case:  controller
            if (fs.isFile &amp;&amp; &#x27;.&#x27; === fs.subDir &amp;&amp; &#x27;controller&#x27; === baseParts[0]) {
                if (&#x27;.js&#x27; !== fs.ext) {
                    return false;
                }
                return {
                    type: &#x27;controller&#x27;
                };
            }

            &#x2F;&#x2F; special case:  mojit
            if (!fs.isFile &amp;&amp; &#x27;.&#x27; === fs.subDir &amp;&amp; &#x27;mojits&#x27; === fs.basename) {
                &#x2F;&#x2F; don&#x27;t bother finding mojits here, since they&#x27;re loaded explicitly in
                &#x2F;&#x2F; the app and bundle in different ways
                return false;
            }

            &#x2F;&#x2F; unknown path
            return true;
        },


        &#x2F;**
         * Called by the ResourceStore to turn a file into a resource.
         * You most often don&#x27;t want to call this directly, but instead to hook
         * into it using the AOP mechanism of &#x60;Y.Plugin.Base&#x60;:
         *
         *     this.beforeHostMethod(&#x27;parseResourceVersion&#x27;, this._myParseResource, this);
         *
         * Generally &#x60;findResourceVersionByConvention()&#x60; and &#x60;parseResourceVersion()&#x60; are meant to work together.
         * &#x60;findResourceVersionByConvention()&#x60; figures out the type (and subtype) of a file, and
         * this method turns the file into an actual resource.
         *
         * @method parseResourceVersion
         * @param {object} source the same as the &#x60;source&#x60; part of a resource
         * @param {string} type the resource type of the file
         * @param {string} subtype the optional resource subtype of the file
         * @param {string} mojitType the name of the mojit
         * @return {object|undefined} the resource version
         *&#x2F;
        parseResourceVersion: function(source, type, subtype, mojitType) {
            var fs = source.fs,
                baseParts = fs.basename.split(&#x27;.&#x27;),
                res;

            &#x2F;&#x2F; app-level resources
            if (&#x27;archetype&#x27; === type || &#x27;command&#x27; === type || &#x27;middleware&#x27; === type) {
                if (&#x27;mojit&#x27; === fs.rootType) {
                    Y.log(type + &#x27; cannot be defined in a mojit. skipping &#x27; + fs.fullPath, &#x27;warn&#x27;, NAME);
                    return;
                }
                res = {
                    source: source,
                    mojit: null,
                    type: type,
                    subtype: subtype,
                    name: fs.basename,
                    affinity: DEFAULT_AFFINITIES[type],
                    selector: &#x27;*&#x27;
                };
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                return res;
            }

            &#x2F;&#x2F; mojit parts with format {name}.{affinity}.{selector}
            if (&#x27;action&#x27; === type ||
                    &#x27;addon&#x27; === type ||
                    &#x27;controller&#x27; === type ||
                    &#x27;model&#x27; === type) {
                res = {
                    source: source,
                    mojit: mojitType,
                    type: type,
                    subtype: subtype,
                    affinity: DEFAULT_AFFINITIES[type],
                    selector: &#x27;*&#x27;
                };
                if (baseParts.length &gt;= 3) {
                    res.selector = baseParts.pop();
                }
                if (baseParts.length &gt;= 2) {
                    res.affinity = baseParts.pop();
                }
                if (baseParts.length !== 1) {
                    Y.log(&#x27;invalid &#x27; + type + &#x27; filename. skipping &#x27; + fs.fullPath, &#x27;warn&#x27;, NAME);
                    return;
                }
                res.name = this._libs.util.webpath(fs.subDirArray.join(PATH_SEP), baseParts.join(&#x27;.&#x27;));
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                &#x2F;&#x2F; special case
                if (&#x27;addon&#x27; === type &amp;&amp; ADDON_SUBTYPES_APPLEVEL[res.subtype]) {
                    res.mojit = null;
                }
                return res;
            }

            &#x2F;&#x2F; mojit parts with format {name}.{selector}
            if (&#x27;asset&#x27; === type || &#x27;binder&#x27; === type) {
                res = {
                    source: source,
                    mojit: mojitType,
                    type: type,
                    subtype: subtype,
                    affinity: DEFAULT_AFFINITIES[type],
                    selector: &#x27;*&#x27;
                };
                if (baseParts.length &gt;= 2) {
                    res.selector = baseParts.pop();
                }
                if (baseParts.length !== 1) {
                    Y.log(&#x27;invalid &#x27; + type + &#x27; filename. skipping &#x27; + fs.fullPath, &#x27;warn&#x27;, NAME);
                    return;
                }
                res.name = this._libs.util.webpath(fs.subDirArray.join(PATH_SEP), baseParts.join(&#x27;.&#x27;));
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                return res;
            }

            &#x2F;&#x2F; special case:  spec
            if (&#x27;spec&#x27; === type) {
                res = {
                    source: source,
                    mojit: mojitType,
                    type: &#x27;spec&#x27;,
                    affinity: DEFAULT_AFFINITIES[type],
                    selector: &#x27;*&#x27;
                };
                if (baseParts.length !== 1) {
                    Y.log(&#x27;invalid spec filename. skipping &#x27; + source.fs.fullPath, &#x27;warn&#x27;, NAME);
                    return;
                }
                res.name = this._libs.util.webpath(source.fs.subDir, baseParts.join(&#x27;.&#x27;));
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                return res;
            }

            &#x2F;&#x2F; special case:  view
            if (&#x27;view&#x27; === type) {
                res = {
                    source: source,
                    mojit: mojitType,
                    type: type,
                    subtype: subtype,
                    view: {
                        outputFormat: fs.ext.substr(1),
                        engine: baseParts.pop()
                    },
                    affinity: DEFAULT_AFFINITIES[type],
                    selector: &#x27;*&#x27;
                };
                if (baseParts.length &gt;= 2) {
                    res.selector = baseParts.pop();
                }
                if (baseParts.length !== 1) {
                    Y.log(&#x27;invalid view filename. skipping &#x27; + fs.fullPath, &#x27;warn&#x27;, NAME);
                    return;
                }
                res.name = this._libs.util.webpath(fs.subDirArray.join(PATH_SEP), baseParts.join(&#x27;.&#x27;));
                res.id = [res.type, res.subtype, res.name].join(&#x27;-&#x27;);
                &#x2F;&#x2F; for performance reasons, we might want to preload all
                &#x2F;&#x2F; views in memory.
                if (this._appConfigStatic.viewEngine &amp;&amp; this._appConfigStatic.viewEngine.preloadTemplates) {
                    res.content = this._libs.fs.readFileSync(source.fs.fullPath, &#x27;utf8&#x27;);
                }
                return res;
            }

            &#x2F;&#x2F; just ignore unknown types
            return;
        },


        &#x2F;**
         * Called by the ResourceStore to register a resource version.
         * You most often don&#x27;t want to call this directly, but instead to hook
         * into it using the AOP mechanism of &#x60;Y.Plugin.Base&#x60;:
         *
         *     this.beforeHostMethod(&#x27;parseResourceVersion&#x27;, this._myParseResource, this);
         *
         * @method addResourceVersion
         * @param {object} res the resource version
         * @return {nothing}
         *&#x2F;
        addResourceVersion: function(res) {
            res.affinity = new Affinity(res.affinity);

            if (res.selector) {
                this.selectors[res.selector] = true;
            }
            if (res.mojit) {
                if (!this._mojitRVs[res.mojit]) {
                    this._mojitRVs[res.mojit] = [];
                }
                this._mojitRVs[res.mojit].push(res);
            } else {
                &#x2F;&#x2F; we use all app-level resource versions
                res.chosen = true;
                this._appRVs.push(res);
            }
        },


        &#x2F;**
         * Called by the ResourceStore to allow RS addons to create resource
         * versions that don&#x27;t otherwise have representation on dist.  You most
         * often don&#x27;t want to call this directly, but instead to hook into it
         * using the AOP mechanism of &#x60;Y.Plugin.Base&#x60;:
         *
         *     this.afterHostMethod(&#x27;makeResourceVersions&#x27;, this._onMakeResourceVersions, this);
         *
         * @method makeResourceVersions
         * @return {nothing}
         *&#x2F;
        makeResourceVersions: function() {
            &#x2F;&#x2F; nothing to do ourselves
        },



        &#x2F;**
         * For each resource, stuff it in a map mojitType-&gt;selector-&gt;affinity
         * that will make it easy to retrieve it later. Then if the lazyResolve config
         * is not set, go through all the possible combinations and resolve all
         * resource versions.
         * @method resolveResourceVersions
         *&#x2F;
        resolveResourceVersions: function () {
            var crtType,
                resources,
                r,
                crtRes,
                e,
                env,
                envs = [&#x27;client&#x27;, &#x27;server&#x27;],
                p,
                posl,
                posls;

            &#x2F;&#x2F; for each resource of each mojit, create the store data structure
            for (crtType in this._mojitRVs) {
                if (this._mojitRVs.hasOwnProperty(crtType)) {
                    resources = this._mojitRVs[crtType];

                    this._mojitDetails[crtType] = {};

                    for (r = 0; r &lt; resources.length; r++) {
                        crtRes = resources[r];

                        &#x2F;&#x2F; create the new selector-&gt;affinity map if it doesn&#x27;t exist
                        if (!this._mojitDetails[crtType][crtRes.selector]) {
                            this._mojitDetails[crtType][crtRes.selector] = {};
                        }
                        if (!this._mojitDetails[crtType][crtRes.selector][crtRes.affinity]) {
                            this._mojitDetails[crtType][crtRes.selector][crtRes.affinity] = [];
                        }

                        this._mojitDetails[crtType][crtRes.selector][crtRes.affinity].push(crtRes);
                    }
                }
            }

            &#x2F;&#x2F; if we don&#x27;t want to lazy resolve, resolve for all posls
            if (!this.lazyResolve) {
                posls = this.selector.getAllPOSLs();

                for (e = 0; e &lt; envs.length; e++) {

                    for (p = 0; p &lt; posls.length; p++) {

                        for (crtType in this._mojitRVs) {
                            if (this._mojitRVs.hasOwnProperty(crtType)) {

                                if (crtType === &#x27;shared&#x27;) {
                                    continue;
                                }

                                this.resolveVersion(crtType, envs[e], posls[p]);
                            }
                        }
                    }
                }
            }

        },

        &#x2F;**
         * Find a mojit details in the resource store at runtime
         * @param  {String} type the mojit type
         * @param  {String} env  the environment: {&#x27;client&#x27;, &#x27;server&#x27;}
         * @param  {Array} posl the ordered list of selectors to look resources with
         * @return {Object} a mojit details
         *&#x2F;
        resolveVersion: function (type, env, posl) {
            var s,
                currentSelector,
                r,
                currentResources,
                currentResourcesLen,
                t,
                currentType,
                types = [type, &#x27;shared&#x27;],
                e,
                affinities = [env, &#x27;common&#x27;],
                poslString = posl.toString(),
                resolvedResources = {},
                mojitRes,
                result;

            if (this._mojitDetailsCache[type + poslString + env]) {
                return JSON.parse(this._mojitDetailsCache[type + poslString + env]);
            }

            for (s = 0; s &lt; posl.length; s++) { &#x2F;&#x2F; ~3
                currentSelector = posl[s];

                for (t = 0; t &lt; types.length; t++) { &#x2F;&#x2F; 2
                    currentType = types[t];

                    for (e = 0; e &lt; affinities.length; e++) { &#x2F;&#x2F; 2
                        currentResources = (this._mojitDetails[currentType][currentSelector] &amp;&amp;
                            this._mojitDetails[currentType][currentSelector][affinities[e]]) || [];

                        &#x2F;&#x2F; remember each resource we find for this posl, type and environment
                        &#x2F;&#x2F; prioritize: we prefer shallower resources
                        currentResources.sort(resourceSortByDepthTest);
                        for (r = 0; r &lt; currentResources.length; r++) { &#x2F;&#x2F; ~3
                            &#x2F;&#x2F; prioritize: we prefer shallower resources
                            resolvedResources[currentResources[r].id] = resolvedResources[currentResources[r].id] || currentResources[r];
                        }
                    }
                }
            }

            mojitRes = this.getResourceVersions({type: &#x27;mojit&#x27;, name: type, selector: &#x27;*&#x27;})[0];
            result = this.resolveMojitDetails(env, posl, type, Y.Object.values(resolvedResources), mojitRes);

            this._mojitDetailsCache[type + poslString + env] = JSON.stringify(result);
            return result;

        },

        &#x2F;&#x2F;====================================================================
        &#x2F;&#x2F; PRIVATE METHODS

        &#x2F;**
         * Used for unit testing.
         * @private
         * @method _mockLib
         * @param {string} name name of library to mock out
         * @param {situation-dependent} lib library to mock out
         * @return {nothing}
         *&#x2F;
        _mockLib: function(name, lib) {
            this._libs[name] = lib;
        },


        &#x2F;**
         * @private
         * @method @parseValidDims
         * @param {object} dims contents of dimensions.json
         * @return {object} lookup hash for dimension keys and values
         *&#x2F;
        _parseValidDims: function(dims) {
            var d,
                dim,
                dimName,
                out = {};
            function grabKeys(dimName, o) {
                var k;
                for (k in o) {
                    if (o.hasOwnProperty(k)) {
                        out[dimName][k] = true;
                        if (Y.Lang.isObject(o[k])) {
                            grabKeys(dimName, o[k]);
                        }
                    }
                }
            }
            for (d = 0; d &lt; dims[0].dimensions.length; d += 1) {
                dim = dims[0].dimensions[d];
                for (dimName in dim) {
                    if (dim.hasOwnProperty(dimName)) {
                        out[dimName] = {};
                        grabKeys(dimName, dim[dimName]);
                    }
                }
            }
            return out;
        },


        &#x2F;**
         * Applies spec inheritance by following the &#x60;base&#x60; and merging up the
         * results.
         * @private
         * @method _expandSpec
         * @param {string} env the runtime environment (either &#x60;client&#x60; or &#x60;server&#x60;)
         * @param {object} ctx runtime context
         * @param {object} spec spec to expand
         * @return {object} expanded sped
         *&#x2F;
        &#x2F;&#x2F; FUTURE:  expose this to RS addons?
        _expandSpec: function(env, ctx, spec) {
            &#x2F;&#x2F; We could add caching in here, but it turns out that it&#x27;s faster
            &#x2F;&#x2F; not to.  This algorithm is pretty simple and a lot of the heavy
            &#x2F;&#x2F; lifting is being done inside the YCB library which has its own
            &#x2F;&#x2F; caching.
            var appConfig,
                base,
                out;

            if (!spec.base) {
                return spec;
            }

            appConfig = this.getAppConfig(ctx);

            &#x2F;&#x2F; appConfig.specs might be undefined, for example in newly created apps
            base = appConfig.specs &amp;&amp; appConfig.specs[spec.base];

            if (!base &amp;&amp; this._specPaths[spec.base]) {
                base = this.config.readConfigYCB(this._specPaths[spec.base], ctx);
            }
            if (!base) {
                throw new Error(&#x27;Unknown base &quot;&#x27; + spec.base + &#x27;&quot;. You should have configured &quot;&#x27; + spec.base + &#x27;&quot; in application.json under specs or used &quot;@&#x27; + spec.base + &#x27;&quot; if you wanted to specify a mojit name.&#x27;);
            }

            out = Y.mojito.util.mergeRecursive(
                this._expandSpec(env, ctx, base),
                spec
            );
            &#x2F;&#x2F; The base will need to carry its ID with it.
            out.id = spec.base;
            out.base = undefined;
            return out;
        },


        &#x2F;**
         * preloads metadata about resources in a package
         * (but not subpackages in its &#x60;node_modules&#x2F;&#x60;)
         *
         * @private
         * @method _preloadPackage
         * @param {object} info metadata about the package
         * @return {nothing}
         *&#x2F;
        _preloadPackage: function(info) {
            var dir,
                pkg,
                visitKey;
            &#x2F;*
            console.log(&#x27;--PACKAGE-- &#x27; + info.depth + &#x27; &#x27; + info.pkg.name + &#x27;@&#x27; + info.pkg.version
                    + &#x27; \t&#x27; + (info.pkg.yahoo &amp;&amp; info.pkg.yahoo.mojito &amp;&amp; info.pkg.yahoo.mojito.type)
                    + &#x27; \t[&#x27; + info.parents.join(&#x27;,&#x27;) + &#x27;]&#x27;
            );
            *&#x2F;
            pkg = {
                name: info.pkg.name,
                version: info.pkg.version,
                depth: info.depth
            };
            if (0 === info.depth) {
                this._appPkg = pkg;
                &#x2F;&#x2F; the actual application is handled specially
                this._preloadApp(pkg);
                return;
            }
            if (!info.pkg.yahoo || !info.pkg.yahoo.mojito) {
                return;
            }
            visitKey = info.pkg.name;
            if (this._packagesVisited[visitKey]) {
                Y.log(&#x27;skipping duplicate package &#x27; + visitKey + &#x27;\nskipping  &#x27; +
                      info.dir + &#x27;\nprev used &#x27; + this._packagesVisited[visitKey], &#x27;debug&#x27;, NAME);
                return;
            }

            switch (info.pkg.yahoo.mojito.type) {
            case &#x27;bundle&#x27;:
                dir = this._libs.path.join(info.dir, info.pkg.yahoo.mojito.location || &#x27;&#x27;);
                this._preloadDirBundle(dir, pkg);
                break;
            case &#x27;mojit&#x27;:
                dir = this._libs.path.join(info.dir, info.pkg.yahoo.mojito.location || &#x27;&#x27;);
                this._preloadDirMojit(dir, &#x27;pkg&#x27;, pkg);
                break;
            default:
                Y.log(&#x27;Unknown package type &quot;&#x27; + info.pkg.yahoo.mojito.type + &#x27;&quot;&#x27;, &#x27;warn&#x27;, NAME);
                break;
            }
            this._packagesVisited[visitKey] = info.dir;
        },


        &#x2F;**
         * preloads metadata about resources in the application directory
         * (but not &#x60;node_modules&#x2F;&#x60;)
         *
         * @private
         * @method _preloadApp
         * @param {object} pkg metadata (name and version) about the app&#x27;s package
         * @return {nothing}
         *&#x2F;
        _preloadApp: function(pkg) {
            var ress,
                r,
                res,
                list,
                i;

            ress = this._findResourcesByConvention(this._config.root, &#x27;app&#x27;, pkg, &#x27;shared&#x27;);
            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];
                if (&#x27;mojit&#x27; !== res.type) {
                    &#x2F;&#x2F; ignore app-level mojits found by convention, since they&#x27;ll be loaded below
                    this.addResourceVersion(ress[r]);
                }
            }

            &#x2F;&#x2F; load mojitsDirs
            list = this._globList(this._config.root, this._appConfigStatic.mojitsDirs);
            for (i = 0; i &lt; list.length; i += 1) {
                this._preloadDirMojits(list[i], &#x27;app&#x27;, pkg);
            }

            &#x2F;&#x2F; load mojitDirs
            list = this._globList(this._config.root, this._appConfigStatic.mojitDirs || []);
            for (i = 0; i &lt; list.length; i += 1) {
                this._preloadDirMojit(list[i], &#x27;app&#x27;, pkg);
            }
        },


        &#x2F;**
         * preloads metadata about resources in a directory
         *
         * @private
         * @method _preloadDirBundle
         * @param {string} dir directory path
         * @param {object} pkg metadata (name and version) about the package
         * @return {nothing}
         *&#x2F;
        _preloadDirBundle: function(dir, pkg) {
            var ress,
                r,
                res;
            &#x2F;&#x2F; FUTURE:  support configuration too

            ress = this._findResourcesByConvention(dir, &#x27;bundle&#x27;, pkg, &#x27;shared&#x27;);
            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];
                this.addResourceVersion(res);
            }
            this._preloadDirMojits(this._libs.path.join(dir, &#x27;mojits&#x27;), &#x27;bundle&#x27;, pkg);
        },


        &#x2F;**
         * preloads a directory containing many mojits
         *
         * @private
         * @method _preloadDirMojits
         * @param {string} dir directory path
         * @param {string} dirType type represented by the &quot;dir&quot; argument.  values are &quot;app&quot;, &quot;bundle&quot;, &quot;pkg&quot;, or &quot;mojit&quot;
         * @param {object} pkg metadata (name and version) about the package
         * @return {nothing}
         *&#x2F;
        _preloadDirMojits: function(dir, dirType, pkg) {
            var i,
                realDirs,
                children,
                childName,
                childPath;
            dir = this._libs.path.resolve(this._config.root, dir);
            if (!this._libs.fs.existsSync(dir)) {
                return;
            }

            children = this._sortedReaddirSync(dir);
            for (i = 0; i &lt; children.length; i += 1) {
                childName = children[i];
                if (&#x27;.&#x27; === childName.substring(0, 1)) {
                    continue;
                }
                childPath = this._libs.path.join(dir, childName);
                this._preloadDirMojit(childPath, dirType, pkg);
            }
        },


        &#x2F;**
         * preloads a directory that represents a single mojit
         *
         * @private
         * @method _preloadDirMojit
         * @param {string} dir directory path
         * @param {string} dirType type represented by the &quot;dir&quot; argument.  values are &quot;app&quot;, &quot;bundle&quot;, &quot;pkg&quot;, or &quot;mojit&quot;
         * @param {object} pkg metadata (name and version) about the package
         * @return {nothing}
         *&#x2F;
        _preloadDirMojit: function(dir, dirType, pkg) {
            var mojitType,
                packageJson,
                definitionJson,
                ress,
                r,
                res;
            dir = this._libs.path.resolve(this._config.root, dir);

            if (!this._libs.fs.existsSync(dir)) {
                return;
            }

            if (!this._libs.fs.statSync(dir).isDirectory()) {
                return;
            }

            if (&#x27;pkg&#x27; === dirType) {
                mojitType = pkg.name;
            } else {
                mojitType = this._libs.path.basename(dir);
            }
            packageJson = this.config.readConfigJSON(this._libs.path.join(dir, &#x27;package.json&#x27;));
            if (packageJson) {
                if (packageJson.name) {
                    mojitType = packageJson.name;
                }

                if (packageJson.engines &amp;&amp; packageJson.engines.mojito) {
                    if (!this._libs.semver.satisfies(mojitoVersion, packageJson.engines.mojito)) {
                        Y.log(&#x27;skipping mojit because of version check &#x27; + dir, &#x27;warn&#x27;, NAME);
                        return;
                    }
                }

                &#x2F;&#x2F; TODO:  register mojit&#x27;s package.json as a static asset, in &quot;static handler&quot; plugin
            }

            definitionJson = this.config.readConfigYCB(this._libs.path.join(dir, &#x27;definition.json&#x27;), {});
            if (definitionJson.appLevel) {
                mojitType = &#x27;shared&#x27;;
            }

            &#x2F;&#x2F; the mojit itself is registered as an app-level resource
            res = {
                source: {
                    fs: this.makeResourceFSMeta(dir, dirType, &#x27;.&#x27;, &#x27;&#x27;, false),
                    pkg: pkg
                },
                type: &#x27;mojit&#x27;,
                name: mojitType,
                id: &#x27;mojit--&#x27; + mojitType,
                affinity: &#x27;common&#x27;,
                selector: &#x27;*&#x27;
            };
            this.addResourceVersion(res);

            ress = this._findResourcesByConvention(dir, &#x27;mojit&#x27;, pkg, mojitType);
            for (r = 0; r &lt; ress.length; r += 1) {
                res = ress[r];
                &#x2F;&#x2F; just in case, only add those resources that really do belong to us
                if (res.mojit === mojitType) {
                    this.addResourceVersion(res);
                }
                &#x2F;&#x2F; FUTURE:  else warn?
            }
        },

        &#x2F;**
         * Finds resources based on our conventions.
         * -Doesn&#x27;t- load mojits or their contents.  That&#x27;s done elsewhere.
         *
         * @private
         * @method _findResourcesByConvention
         * @param {string} dir directory from which to find resources
         * @param {string} dirType type represented by the &quot;dir&quot; argument.  values are &quot;app&quot;, &quot;bundle&quot;, &quot;pkg&quot;, or &quot;mojit&quot;
         * @param {object} pkg metadata (name and version) about the package
         * @param {string|null} mojitType name of mojit to which the resource belongs
         * @return {array} list of resources
         *&#x2F;
        _findResourcesByConvention: function(dir, dirType, pkg, mojitType) {
            var me = this,
                ress = [];
            &#x2F;&#x2F;console.log(&#x27;-- FIND RESOURCES BY CONVENTION -- &#x27; + pkg.name + &#x27;@&#x27; + pkg.version + &#x27; -- &#x27; + mojitType);

            this._walkDirRecursive(dir, function(error, subdir, file, isFile) {
                var source, ret, res;

                if (&#x27;node_modules&#x27; === file) {
                    return false;
                }
                if (&#x27;libs&#x27; === file &amp;&amp; &#x27;test&#x27; !== me._appConfigStatic.env) {
                    return false;
                }
                if (&#x27;tests&#x27; === file &amp;&amp; &#x27;test&#x27; !== me._appConfigStatic.env) {
                    return false;
                }

                source = {
                    fs: me.makeResourceFSMeta(dir, dirType, subdir, file, isFile),
                    pkg: pkg
                };

                if (me._skipBadPath(source.fs)) {
                    return false;
                }

                ret = me.findResourceVersionByConvention(source, mojitType);
                if (&#x27;object&#x27; === typeof ret) {
                    if (ret.skipSubdirParts) {
                        source.fs.subDirArray = source.fs.subDirArray.slice(ret.skipSubdirParts);
                        source.fs.subDir = source.fs.subDirArray.join(PATH_SEP) || &#x27;.&#x27;;
                    }
                    res = me.parseResourceVersion(source, ret.type, ret.subtype, mojitType);
                    if (&#x27;object&#x27; === typeof res) {
                        ress.push(res);
                    }
                    &#x2F;&#x2F; don&#x27;t recurse into resources that are directories
                    return false;
                }
                return ret;
            });

            return ress;
        },


        &#x2F;**
         * Indicates whether file should be skipped based on its path
         *
         * @private
         * @method _skipBadPath
         * @param {object} pathParts the &quot;source.fs&quot; part of the resource
         * @return {boolean} true indicates that the file should be skipped
         *&#x2F;
        _skipBadPath: function(fs) {
            if (fs.isFile &amp;&amp; fs.ext.substr(1).match(isNotAlphaNum)) {
                return true;
            }
            return false;
        },


        &#x2F;**
         * A wrapper for &#x60;fs.readdirSync()&#x60; that guarantees ordering. The order
         * in which the file system is walked is significant within the resource
         * store, e.g., when looking up a matching context.
         *
         * @private
         * @method _sortedReaddirSync
         * @param {string} path directory to read
         * @return {array} files in the directory
         *&#x2F;
        _sortedReaddirSync: function(path) {
            var out = this._libs.fs.readdirSync(path);
            return out.sort();
        },


        &#x2F;**
         * Recursively walks a directory
         * @private
         * @method _walkDirRecursive
         * @param {string} dir directory to start at
         * @param {function(error, subdir, name, isFile)} cb callback called for each file
         * @param {string} _subdir INTERNAL argument for recursion, please ignore
         *&#x2F;
        _walkDirRecursive: function(dir, cb, _subdir) {
            var subdir,
                fulldir,
                children,
                i,
                childName,
                childPath,
                childFullPath,
                childStat;

            subdir = _subdir || &#x27;.&#x27;;
            fulldir = this._libs.path.join(dir, subdir);
            if (!this._libs.fs.existsSync(fulldir)) {
                return;
            }

            children = this._sortedReaddirSync(fulldir);
            for (i = 0; i &lt; children.length; i += 1) {
                childName = children[i];
                if (&#x27;.&#x27; === childName.substring(0, 1)) {
                    continue;
                }
                if (&#x27;node_modules&#x27; === childName) {
                    continue;
                }
                childPath = this._libs.path.join(subdir, childName);
                childFullPath = this._libs.path.join(dir, childPath);
                try {
                    childStat = this._libs.fs.statSync(childFullPath);
                } catch (e) {
                    Y.log(&#x27;invalid file. skipping &#x27; + childFullPath, &#x27;warn&#x27;, NAME);
                    continue;
                }
                if (childStat.isFile()) {
                    cb(null, subdir, childName, true);
                } else if (childStat.isDirectory()) {
                    if (cb(null, subdir, childName, false)) {
                        this._walkDirRecursive(dir, cb, childPath);
                    }
                }
            }
        },


        &#x2F;**
         * Takes a list of globs and turns it into a list of matching paths.
         * @private
         * @method _globList
         * @param {string} prefix prefix for every path in the list
         * @param {array} list list of globs
         * @return {array} list of paths matching the globs
         *&#x2F;
        _globList: function(prefix, list) {
            var found = [],
                i,
                glob;
            for (i = 0; i &lt; list.length; i += 1) {
                glob = list[i];
                glob = this._libs.path.resolve(prefix, glob);
                found = found.concat(this._libs.glob.sync(glob, {}));
            }
            return found;
        },


        &#x2F;**
         * Augments this resource store&#x27;s Y object with the specified YUI modules.
         * @private
         * @method _yuiUseSync
         * @param {object} modules YUI module configuration information
         * @return {nothing}
         *&#x2F;
        _yuiUseSync: function(modules) {
            Y.applyConfig({
                useSync: true,
                modules: modules
            });
            Y.use.apply(Y, Object.keys(modules));
            Y.applyConfig({ useSync: false });
        }


    });

    Y.namespace(&#x27;mojito&#x27;);
    Y.mojito.ResourceStore = ResourceStore;


}, &#x27;0.0.1&#x27;, { requires: [
    &#x27;base&#x27;,
    &#x27;oop&#x27;,
    &#x27;mojito-util&#x27;
]});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>

<!-- SpaceID=0 robot -->

<!-- VER-3.0.246810 -->
<!-- p1.ydn.bf1.yahoo.com uncompressed/chunked Fri Oct  4 11:13:22 PDT 2013 -->
